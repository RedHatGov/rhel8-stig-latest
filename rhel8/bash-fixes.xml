<fix-content system="urn:xccdf:fix:script:sh" xmlns="http://checklists.nist.gov/xccdf/1.1"><fix-group id="bash" system="urn:xccdf:fix:script:sh" xmlns="http://checklists.nist.gov/xccdf/1.1"><fix complexity="low" disruption="low" reboot="false" rule="sebool_gitosis_can_sendmail" strategy="enable">
var_gitosis_can_sendmail="<sub idref="var_gitosis_can_sendmail" />"

setsebool -P gitosis_can_sendmail $var_gitosis_can_sendmail
</fix><fix rule="no_rsh_trust_files">find /home -maxdepth 2 -type f -name .rhosts -exec rm -f '{}' \;

if [ -f /etc/hosts.equiv ]; then
	/bin/rm -f /etc/hosts.equiv
fi
</fix><fix rule="postfix_prevent_unrestricted_relay">
if ! grep -q ^smtpd_client_restrictions /etc/postfix/main.cf; then
	echo "smtpd_client_restrictions = permit_mynetworks,reject" &gt;&gt; /etc/postfix/main.cf
else
	sed -i "s/^smtpd_client_restrictions.*/smtpd_client_restrictions = permit_mynetworks,reject/g" /etc/postfix/main.cf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_sssd_installed" strategy="enable">
if ! rpm -q --quiet "sssd" ; then
    yum install -y "sssd"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_httpd_server_conf_d_files" strategy="configure">
find /etc/httpd/conf.d/ -regex '^.*$' -exec chmod 0640 {} \;
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_autofs_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'autofs.service'
"$SYSTEMCTL_EXEC" disable 'autofs.service'
"$SYSTEMCTL_EXEC" mask 'autofs.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^autofs.socket'; then
    "$SYSTEMCTL_EXEC" stop 'autofs.socket'
    "$SYSTEMCTL_EXEC" disable 'autofs.socket'
    "$SYSTEMCTL_EXEC" mask 'autofs.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'autofs.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_can_connect_mythtv" strategy="enable">
var_httpd_can_connect_mythtv="<sub idref="var_httpd_can_connect_mythtv" />"

setsebool -P httpd_can_connect_mythtv $var_httpd_can_connect_mythtv
</fix><fix rule="audit_rules_dac_modification_lsetxattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S lsetxattr.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="dconf_gnome_disable_user_list">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/login-screen\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/gdm.d/00-security-settings"
DBDIR="/etc/dconf/db/gdm.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/login-screen]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "disable-user-list" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*disable-user-list" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*disable-user-list\\s*=\\s*.*/disable-user-list=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/login-screen\\]|a\\disable-user-list=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/login-screen/disable-user-list$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/gdm.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/login-screen/disable-user-list" &gt;&gt; "/etc/dconf/db/gdm.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_tar_installed" strategy="enable">
if ! rpm -q --quiet "tar" ; then
    yum install -y "tar"
fi
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_default_accept_redirects" strategy="disable">
sysctl_net_ipv4_conf_default_accept_redirects_value="<sub idref="sysctl_net_ipv4_conf_default_accept_redirects_value" />"

#
# Set runtime for net.ipv4.conf.default.accept_redirects
#
/sbin/sysctl -q -n -w net.ipv4.conf.default.accept_redirects="$sysctl_net_ipv4_conf_default_accept_redirects_value"

#
# If net.ipv4.conf.default.accept_redirects present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.conf.default.accept_redirects = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.default.accept_redirects' "$sysctl_net_ipv4_conf_default_accept_redirects_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_samba-common_installed" strategy="enable">
if ! rpm -q --quiet "samba-common" ; then
    yum install -y "samba-common"
fi
</fix><fix reboot="false" rule="mount_option_nodev_removable_partitions">
var_removable_partition="<sub idref="var_removable_partition" />"
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab "$var_removable_partition" || { echo "Not remediating, because there is no record of $var_removable_partition in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "$var_removable_partition" "nodev" "" ""

	ensure_partition_is_mounted "$var_removable_partition"
}

perform_remediation
</fix><fix rule="accounts_maximum_age_login_defs">
var_accounts_maximum_age_login_defs="<sub idref="var_accounts_maximum_age_login_defs" />"

grep -q ^PASS_MAX_DAYS /etc/login.defs &amp;&amp; \
  sed -i "s/PASS_MAX_DAYS.*/PASS_MAX_DAYS     $var_accounts_maximum_age_login_defs/g" /etc/login.defs
if ! [ $? -eq 0 ]; then
    echo "PASS_MAX_DAYS      $var_accounts_maximum_age_login_defs" &gt;&gt; /etc/login.defs
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_samba_run_unconfined" strategy="enable">
var_samba_run_unconfined="<sub idref="var_samba_run_unconfined" />"

setsebool -P samba_run_unconfined $var_samba_run_unconfined
</fix><fix rule="audit_rules_privileged_commands_chsh">

PATTERN="-a always,exit -F path=/usr/bin/chsh\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/chsh -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="accounts_tmout">
var_accounts_tmout="<sub idref="var_accounts_tmout" />"

if grep --silent ^TMOUT /etc/profile ; then
        sed -i "s/^TMOUT.*/TMOUT=$var_accounts_tmout/g" /etc/profile
else
        echo -e "\n# Set TMOUT to $var_accounts_tmout per security requirements" &gt;&gt; /etc/profile
        echo "TMOUT=$var_accounts_tmout" &gt;&gt; /etc/profile
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rhnsd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rhnsd.service'
"$SYSTEMCTL_EXEC" disable 'rhnsd.service'
"$SYSTEMCTL_EXEC" mask 'rhnsd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rhnsd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rhnsd.socket'
    "$SYSTEMCTL_EXEC" disable 'rhnsd.socket'
    "$SYSTEMCTL_EXEC" mask 'rhnsd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rhnsd.service' || true
</fix><fix rule="no_direct_root_logins">echo &gt; /etc/securetty
</fix><fix rule="dconf_gnome_disable_wifi_create">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/nm-applet\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/nm-applet]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "disable-wifi-create" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*disable-wifi-create" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*disable-wifi-create\\s*=\\s*.*/disable-wifi-create=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/nm-applet\\]|a\\disable-wifi-create=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/nm-applet/disable-wifi-create$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/nm-applet/disable-wifi-create" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_set_loglevel_verbose" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*LogLevel\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "LogLevel VERBOSE" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "LogLevel VERBOSE" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_kernel_core_pattern" strategy="disable">

#
# Set runtime for kernel.core_pattern
#
/sbin/sysctl -q -n -w kernel.core_pattern="|/bin/false"

#
# If kernel.core_pattern present in /etc/sysctl.conf, change value to "|/bin/false"
#	else, add "kernel.core_pattern = |/bin/false" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^kernel.core_pattern' "|/bin/false" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_setroubleshoot_removed" strategy="disable">
# CAUTION: This remediation script will remove setroubleshoot
#	   from the system, and may remove any packages
#	   that depend on setroubleshoot. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "setroubleshoot" ; then
    yum remove -y "setroubleshoot"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rpcidmapd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rpcidmapd.service'
"$SYSTEMCTL_EXEC" disable 'rpcidmapd.service'
"$SYSTEMCTL_EXEC" mask 'rpcidmapd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rpcidmapd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rpcidmapd.socket'
    "$SYSTEMCTL_EXEC" disable 'rpcidmapd.socket'
    "$SYSTEMCTL_EXEC" mask 'rpcidmapd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rpcidmapd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_ping" strategy="enable">
var_selinuxuser_ping="<sub idref="var_selinuxuser_ping" />"

setsebool -P selinuxuser_ping $var_selinuxuser_ping
</fix><fix rule="audit_rules_execution_chcon">

PATTERN="-a always,exit -F path=/usr/bin/chcon\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_cron_d" strategy="configure">

chown 0 /etc/cron.d/
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_etc_group" strategy="configure">

chown 0 /etc/group
</fix><fix rule="sshd_set_idle_timeout">
sshd_idle_timeout_value="<sub idref="sshd_idle_timeout_value" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/ssh/sshd_config' '^ClientAliveInterval' $sshd_idle_timeout_value '@CCENUM@' '%s %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_rsh_removed" strategy="disable">
# CAUTION: This remediation script will remove rsh
#	   from the system, and may remove any packages
#	   that depend on rsh. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "rsh" ; then
    yum remove -y "rsh"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_sysadm_exec_content" strategy="enable">
var_sysadm_exec_content="<sub idref="var_sysadm_exec_content" />"

setsebool -P sysadm_exec_content $var_sysadm_exec_content
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_disable_gssapi_auth" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*GSSAPIAuthentication\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "GSSAPIAuthentication no" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "GSSAPIAuthentication no" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix complexity="low" disruption="low" reboot="false" rule="coredump_disable_backtraces" strategy="restrict">if [ -e "/etc/systemd/coredump.conf" ] ; then
    LC_ALL=C sed -i "/^\s*ProcessSizeMax\s*=\s*/Id" "/etc/systemd/coredump.conf"
else
    touch "/etc/systemd/coredump.conf"
fi
cp "/etc/systemd/coredump.conf" "/etc/systemd/coredump.conf.bak"
# Insert at the end of the file
printf '%s\n' "ProcessSizeMax=0" &gt;&gt; "/etc/systemd/coredump.conf"
# Clean up after ourselves.
rm "/etc/systemd/coredump.conf.bak"
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_all_log_martians" strategy="disable">
sysctl_net_ipv4_conf_all_log_martians_value="<sub idref="sysctl_net_ipv4_conf_all_log_martians_value" />"

#
# Set runtime for net.ipv4.conf.all.log_martians
#
/sbin/sysctl -q -n -w net.ipv4.conf.all.log_martians="$sysctl_net_ipv4_conf_all_log_martians_value"

#
# If net.ipv4.conf.all.log_martians present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.conf.all.log_martians = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.all.log_martians' "$sysctl_net_ipv4_conf_all_log_martians_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_nfs-utils_removed" strategy="disable">
# CAUTION: This remediation script will remove nfs-utils
#	   from the system, and may remove any packages
#	   that depend on nfs-utils. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "nfs-utils" ; then
    yum remove -y "nfs-utils"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_enable_cgi" strategy="enable">
var_httpd_enable_cgi="<sub idref="var_httpd_enable_cgi" />"

setsebool -P httpd_enable_cgi $var_httpd_enable_cgi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_rw_noexattrfile" strategy="enable">
var_selinuxuser_rw_noexattrfile="<sub idref="var_selinuxuser_rw_noexattrfile" />"

setsebool -P selinuxuser_rw_noexattrfile $var_selinuxuser_rw_noexattrfile
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_glance_api_can_network" strategy="enable">
var_glance_api_can_network="<sub idref="var_glance_api_can_network" />"

setsebool -P glance_api_can_network $var_glance_api_can_network
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_etc_gshadow" strategy="configure">

chgrp 0 /etc/gshadow
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_sshd_private_key" strategy="configure">
find /etc/ssh/ -regex '^.*_key$' -exec chmod 0640 {} \;
</fix><fix rule="audit_rules_unsuccessful_file_modification_openat_o_creat">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_prosody_bind_http_port" strategy="enable">
var_prosody_bind_http_port="<sub idref="var_prosody_bind_http_port" />"

setsebool -P prosody_bind_http_port $var_prosody_bind_http_port
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_nfs_export_all_ro" strategy="enable">
var_nfs_export_all_ro="<sub idref="var_nfs_export_all_ro" />"

setsebool -P nfs_export_all_ro $var_nfs_export_all_ro
</fix><fix rule="audit_rules_unsuccessful_file_modification_openat_rule_order">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix rule="gnome_gdm_disable_automatic_login">
if rpm --quiet -q gdm
then
	if ! grep -q "^AutomaticLoginEnable=" /etc/gdm/custom.conf
	then
		sed -i "/^\[daemon\]/a \
		AutomaticLoginEnable=False" /etc/gdm/custom.conf
	else
		sed -i "s/^AutomaticLoginEnable=.*/AutomaticLoginEnable=False/g" /etc/gdm/custom.conf
	fi
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_share_music" strategy="enable">
var_selinuxuser_share_music="<sub idref="var_selinuxuser_share_music" />"

setsebool -P selinuxuser_share_music $var_selinuxuser_share_music
</fix><fix rule="usbguard_allow_hub">
if ! grep -Eq '^[ \t]*allow[ \t]+with-interface[ \t]+equals[ \t]+\{[ \t]+09:00:\*[ \t]+\}[ \t]*$' /etc/usbguard/rules.conf ; then
	echo "allow with-interface equals { 09:00:* }" &gt;&gt; /etc/usbguard/rules.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mplayer_execstack" strategy="enable">
var_mplayer_execstack="<sub idref="var_mplayer_execstack" />"

setsebool -P mplayer_execstack $var_mplayer_execstack
</fix><fix rule="dconf_gnome_screensaver_user_info">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/desktop/screensaver\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/desktop/screensaver]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "show-full-name-in-top-bar" "false" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "false")"
    if grep -q "^\\s*show-full-name-in-top-bar" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*show-full-name-in-top-bar\\s*=\\s*.*/show-full-name-in-top-bar=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/desktop/screensaver\\]|a\\show-full-name-in-top-bar=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/screensaver/show-full-name-in-top-bar$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/screensaver/show-full-name-in-top-bar" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rsh_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rsh.service'
"$SYSTEMCTL_EXEC" disable 'rsh.service'
"$SYSTEMCTL_EXEC" mask 'rsh.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rsh.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rsh.socket'
    "$SYSTEMCTL_EXEC" disable 'rsh.socket'
    "$SYSTEMCTL_EXEC" mask 'rsh.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rsh.service' || true
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_ip_forward" strategy="disable">

#
# Set runtime for net.ipv4.ip_forward
#
/sbin/sysctl -q -n -w net.ipv4.ip_forward="0"

#
# If net.ipv4.ip_forward present in /etc/sysctl.conf, change value to "0"
#	else, add "net.ipv4.ip_forward = 0" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.ip_forward' "0" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_geolite2-country_removed" strategy="disable">
# CAUTION: This remediation script will remove geolite2-country
#	   from the system, and may remove any packages
#	   that depend on geolite2-country. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "geolite2-country" ; then
    yum remove -y "geolite2-country"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mozilla_plugin_use_spice" strategy="enable">
var_mozilla_plugin_use_spice="<sub idref="var_mozilla_plugin_use_spice" />"

setsebool -P mozilla_plugin_use_spice $var_mozilla_plugin_use_spice
</fix><fix rule="audit_rules_unsuccessful_file_modification_fsetxattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fsetxattr -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fsetxattr -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S fsetxattr -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S fsetxattr -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="audit_rules_privileged_commands_crontab">

PATTERN="-a always,exit -F path=/usr/bin/crontab\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/crontab -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_quagga_removed" strategy="disable">
# CAUTION: This remediation script will remove quagga
#	   from the system, and may remove any packages
#	   that depend on quagga. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "quagga" ; then
    yum remove -y "quagga"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_mod_auth_ntlm_winbind" strategy="enable">
var_httpd_mod_auth_ntlm_winbind="<sub idref="var_httpd_mod_auth_ntlm_winbind" />"

setsebool -P httpd_mod_auth_ntlm_winbind $var_httpd_mod_auth_ntlm_winbind
</fix><fix complexity="low" disruption="low" reboot="false" rule="force_opensc_card_drivers" strategy="configure">
var_smartcard_drivers="<sub idref="var_smartcard_drivers" />"

OPENSC_TOOL="/usr/bin/opensc-tool"

if [ -f "${OPENSC_TOOL}" ]; then
    ${OPENSC_TOOL} -S app:default:force_card_driver:$var_smartcard_drivers
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_anon_write" strategy="enable">
var_httpd_anon_write="<sub idref="var_httpd_anon_write" />"

setsebool -P httpd_anon_write $var_httpd_anon_write
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_minidlna_read_generic_user_content" strategy="enable">
var_minidlna_read_generic_user_content="<sub idref="var_minidlna_read_generic_user_content" />"

setsebool -P minidlna_read_generic_user_content $var_minidlna_read_generic_user_content
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_fs_protected_symlinks" strategy="disable">

#
# Set runtime for fs.protected_symlinks
#
/sbin/sysctl -q -n -w fs.protected_symlinks="1"

#
# If fs.protected_symlinks present in /etc/sysctl.conf, change value to "1"
#	else, add "fs.protected_symlinks = 1" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^fs.protected_symlinks' "1" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_disable_pubkey_auth" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*PubkeyAuthentication\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "PubkeyAuthentication no" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "PubkeyAuthentication no" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix rule="audit_rules_time_settimeofday">
<sub idref="function_perform_audit_adjtimex_settimeofday_stime_remediation" />
perform_audit_adjtimex_settimeofday_stime_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_fcron_crond" strategy="enable">
var_fcron_crond="<sub idref="var_fcron_crond" />"

setsebool -P fcron_crond $var_fcron_crond
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_sysstat_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'sysstat.service'
"$SYSTEMCTL_EXEC" disable 'sysstat.service'
"$SYSTEMCTL_EXEC" mask 'sysstat.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^sysstat.socket'; then
    "$SYSTEMCTL_EXEC" stop 'sysstat.socket'
    "$SYSTEMCTL_EXEC" disable 'sysstat.socket'
    "$SYSTEMCTL_EXEC" mask 'sysstat.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'sysstat.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_execmem" strategy="enable">
var_httpd_execmem="<sub idref="var_httpd_execmem" />"

setsebool -P httpd_execmem $var_httpd_execmem
</fix><fix complexity="low" disruption="low" reboot="false" rule="accounts_password_pam_maxclassrepeat" strategy="restrict">
var_password_pam_maxclassrepeat="<sub idref="var_password_pam_maxclassrepeat" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/security/pwquality.conf' '^maxclassrepeat' $var_password_pam_maxclassrepeat '@CCENUM@' '%s = %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_use_fusefs" strategy="enable">
var_httpd_use_fusefs="<sub idref="var_httpd_use_fusefs" />"

setsebool -P httpd_use_fusefs $var_httpd_use_fusefs
</fix><fix rule="audit_rules_etc_passwd_open_by_handle_at">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S open_by_handle_at -F a2&amp;03 -F path=/etc/passwd.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix reboot="false" rule="mount_option_dev_shm_noexec">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "no" = 'yes'; then
		assert_mount_point_in_fstab /dev/shm || { echo "Not remediating, because there is no record of /dev/shm in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/dev/shm" "noexec" "tmpfs" "tmpfs"

	ensure_partition_is_mounted "/dev/shm"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_haproxy_connect_any" strategy="enable">
var_haproxy_connect_any="<sub idref="var_haproxy_connect_any" />"

setsebool -P haproxy_connect_any $var_haproxy_connect_any
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_vfat_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install vfat" /etc/modprobe.d/vfat.conf ; then
	sed -i 's/^install vfat.*/install vfat /bin/true/g' /etc/modprobe.d/vfat.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/vfat.conf
	echo "install vfat /bin/true" &gt;&gt; /etc/modprobe.d/vfat.conf
fi
</fix><fix rule="accounts_password_minlen_login_defs">
declare var_accounts_password_minlen_login_defs
var_accounts_password_minlen_login_defs="<sub idref="var_accounts_password_minlen_login_defs" />"

grep -q ^PASS_MIN_LEN /etc/login.defs &amp;&amp; \
sed -i "s/PASS_MIN_LEN.*/PASS_MIN_LEN\t$var_accounts_password_minlen_login_defs/g" /etc/login.defs
if ! [ $? -eq 0 ]
then
  echo -e "PASS_MIN_LEN\t$var_accounts_password_minlen_login_defs" &gt;&gt; /etc/login.defs
fi
</fix><fix rule="audit_rules_dac_modification_fchmodat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fchmodat.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_postgresql_selinux_users_ddl" strategy="enable">
var_postgresql_selinux_users_ddl="<sub idref="var_postgresql_selinux_users_ddl" />"

setsebool -P postgresql_selinux_users_ddl $var_postgresql_selinux_users_ddl
</fix><fix rule="sssd_ssh_known_hosts_timeout">
var_sssd_ssh_known_hosts_timeout="<sub idref="var_sssd_ssh_known_hosts_timeout" />"

SSSD_CONF="/etc/sssd/sssd.conf"
SSH_KNOWN_HOSTS_TIMEOUT_REGEX="[[:space:]]*\[ssh]([^\n\[]*\n+)+?[[:space:]]*ssh_known_hosts_timeout"
SSH_REGEX="[[:space:]]*\[ssh]"

# Try find [ssh] and ssh_known_hosts_timeout in sssd.conf, if it exists, set to
# var_sssd_ssh_known_hosts_timeout, if it isn't here, add it, if [ssh] doesn't
# exist, add it there
if grep -qzosP $SSH_KNOWN_HOSTS_TIMEOUT_REGEX $SSSD_CONF; then
        sed -i "s/ssh_known_hosts_timeout[^(\n)]*/ssh_known_hosts_timeout = $var_sssd_ssh_known_hosts_timeout/" $SSSD_CONF
elif grep -qs $SSH_REGEX $SSSD_CONF; then
        sed -i "/$SSH_REGEX/a ssh_known_hosts_timeout = $var_sssd_ssh_known_hosts_timeout" $SSSD_CONF
else
        mkdir -p /etc/sssd
        touch $SSSD_CONF
        echo -e "[ssh]\nssh_known_hosts_timeout = $var_sssd_ssh_known_hosts_timeout" &gt;&gt; $SSSD_CONF
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="accounts_password_pam_lcredit" strategy="restrict">
var_password_pam_lcredit="<sub idref="var_password_pam_lcredit" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/security/pwquality.conf' '^lcredit' $var_password_pam_lcredit '@CCENUM@' '%s = %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_bind_removed" strategy="disable">
# CAUTION: This remediation script will remove bind
#	   from the system, and may remove any packages
#	   that depend on bind. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "bind" ; then
    yum remove -y "bind"
fi
</fix><fix rule="chronyd_or_ntpd_specify_remote_server">
var_multiple_time_servers="<sub idref="var_multiple_time_servers" />"

config_file="/etc/ntp.conf"
/usr/sbin/pidof ntpd || config_file="/etc/chrony.conf"

if ! grep -q ^server "$config_file" ; then
  if ! grep -q '#[[:space:]]*server' "$config_file" ; then
    for server in $(echo "$var_multiple_time_servers" | tr ',' '\n') ; do
      printf '\nserver %s iburst' "$server" &gt;&gt; "$config_file"
    done
  else
    sed -i 's/#[ \t]*server/server/g' "$config_file"
  fi
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rpcbind_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rpcbind.service'
"$SYSTEMCTL_EXEC" disable 'rpcbind.service'
"$SYSTEMCTL_EXEC" mask 'rpcbind.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rpcbind.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rpcbind.socket'
    "$SYSTEMCTL_EXEC" disable 'rpcbind.socket'
    "$SYSTEMCTL_EXEC" mask 'rpcbind.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rpcbind.service' || true
</fix><fix rule="file_permissions_efi_grub2_cfg">chmod 700 /boot/efi/EFI/redhat/grub.cfg
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_ntpdate_removed" strategy="disable">
# CAUTION: This remediation script will remove ntpdate
#	   from the system, and may remove any packages
#	   that depend on ntpdate. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "ntpdate" ; then
    yum remove -y "ntpdate"
fi
</fix><fix reboot="false" rule="mount_option_var_tmp_nodev">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/tmp || { echo "Not remediating, because there is no record of /var/tmp in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/tmp" "nodev" "" ""

	ensure_partition_is_mounted "/var/tmp"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_deny_ptrace" strategy="enable">
var_deny_ptrace="<sub idref="var_deny_ptrace" />"

setsebool -P deny_ptrace $var_deny_ptrace
</fix><fix rule="auditd_data_retention_space_left_action">
var_auditd_space_left_action="<sub idref="var_auditd_space_left_action" />"

#
# If space_left_action present in /etc/audit/auditd.conf, change value
# to var_auditd_space_left_action, else
# add "space_left_action = $var_auditd_space_left_action" to /etc/audit/auditd.conf
#

AUDITCONFIG=/etc/audit/auditd.conf
<sub idref="function_replace_or_append" />
replace_or_append $AUDITCONFIG '^space_left_action' "$var_auditd_space_left_action" "@CCENUM@"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_use_fusefs_home_dirs" strategy="enable">
var_use_fusefs_home_dirs="<sub idref="var_use_fusefs_home_dirs" />"

setsebool -P use_fusefs_home_dirs $var_use_fusefs_home_dirs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_mod_auth_pam" strategy="enable">
var_httpd_mod_auth_pam="<sub idref="var_httpd_mod_auth_pam" />"

setsebool -P httpd_mod_auth_pam $var_httpd_mod_auth_pam
</fix><fix rule="audit_rules_for_ospp">
cp /usr/share/doc/audit*/rules/10-base-config.rules /etc/audit/rules.d
cp /usr/share/doc/audit*/rules/11-loginuid.rules /etc/audit/rules.d
cp /usr/share/doc/audit*/rules/30-ospp-v42.rules /etc/audit/rules.d
cp /usr/share/doc/audit*/rules/43-module-load.rules /etc/audit/rules.d

augenrules --load
</fix><fix rule="dconf_gnome_enable_smartcard_auth">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/login-screen\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/gdm.d/00-security-settings"
DBDIR="/etc/dconf/db/gdm.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/login-screen]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "enable-smartcard-authentication" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*enable-smartcard-authentication" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*enable-smartcard-authentication\\s*=\\s*.*/enable-smartcard-authentication=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/login-screen\\]|a\\enable-smartcard-authentication=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/login-screen/enable-smartcard-authentication$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/gdm.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/login-screen/enable-smartcard-authentication" &gt;&gt; "/etc/dconf/db/gdm.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_webadm_manage_user_files" strategy="enable">
var_webadm_manage_user_files="<sub idref="var_webadm_manage_user_files" />"

setsebool -P webadm_manage_user_files $var_webadm_manage_user_files
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_httpd_server_conf_files" strategy="configure">
find /etc/httpd/conf/ -regex '^.*$' -exec chmod 0640 {} \;
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_abrt-addon-python_removed" strategy="disable">
# CAUTION: This remediation script will remove abrt-addon-python
#	   from the system, and may remove any packages
#	   that depend on abrt-addon-python. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "abrt-addon-python" ; then
    yum remove -y "abrt-addon-python"
fi
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_cramfs_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install cramfs" /etc/modprobe.d/cramfs.conf ; then
	sed -i 's/^install cramfs.*/install cramfs /bin/true/g' /etc/modprobe.d/cramfs.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/cramfs.conf
	echo "install cramfs /bin/true" &gt;&gt; /etc/modprobe.d/cramfs.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_nfslock_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'nfslock.service'
"$SYSTEMCTL_EXEC" disable 'nfslock.service'
"$SYSTEMCTL_EXEC" mask 'nfslock.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^nfslock.socket'; then
    "$SYSTEMCTL_EXEC" stop 'nfslock.socket'
    "$SYSTEMCTL_EXEC" disable 'nfslock.socket'
    "$SYSTEMCTL_EXEC" mask 'nfslock.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'nfslock.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_nis_removed" strategy="disable">
# CAUTION: This remediation script will remove nis
#	   from the system, and may remove any packages
#	   that depend on nis. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "nis" ; then
    yum remove -y "nis"
fi
</fix><fix rule="audit_rules_execution_setfiles">

PATTERN="-a always,exit -F path=/usr/sbin/setfiles\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/sbin/setfiles -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_default_send_redirects" strategy="disable">

#
# Set runtime for net.ipv4.conf.default.send_redirects
#
/sbin/sysctl -q -n -w net.ipv4.conf.default.send_redirects="0"

#
# If net.ipv4.conf.default.send_redirects present in /etc/sysctl.conf, change value to "0"
#	else, add "net.ipv4.conf.default.send_redirects = 0" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.default.send_redirects' "0" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_dnf-plugin-subscription-manager_installed" strategy="enable">
if ! rpm -q --quiet "dnf-plugin-subscription-manager" ; then
    yum install -y "dnf-plugin-subscription-manager"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_use_execmem" strategy="enable">
var_virt_use_execmem="<sub idref="var_virt_use_execmem" />"

setsebool -P virt_use_execmem $var_virt_use_execmem
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_sge_use_nfs" strategy="enable">
var_sge_use_nfs="<sub idref="var_sge_use_nfs" />"

setsebool -P sge_use_nfs $var_sge_use_nfs
</fix><fix complexity="low" disruption="low" reboot="false" rule="timer_dnf-automatic_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'dnf-automatic.timer'
"$SYSTEMCTL_EXEC" enable 'dnf-automatic.timer'
</fix><fix rule="audit_rules_dac_modification_fchmod">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fchmod.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cluster_can_network_connect" strategy="enable">
var_cluster_can_network_connect="<sub idref="var_cluster_can_network_connect" />"

setsebool -P cluster_can_network_connect $var_cluster_can_network_connect
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_all_secure_redirects" strategy="disable">
sysctl_net_ipv4_conf_all_secure_redirects_value="<sub idref="sysctl_net_ipv4_conf_all_secure_redirects_value" />"

#
# Set runtime for net.ipv4.conf.all.secure_redirects
#
/sbin/sysctl -q -n -w net.ipv4.conf.all.secure_redirects="$sysctl_net_ipv4_conf_all_secure_redirects_value"

#
# If net.ipv4.conf.all.secure_redirects present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.conf.all.secure_redirects = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.all.secure_redirects' "$sysctl_net_ipv4_conf_all_secure_redirects_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_git_session_bind_all_unreserved_ports" strategy="enable">
var_git_session_bind_all_unreserved_ports="<sub idref="var_git_session_bind_all_unreserved_ports" />"

setsebool -P git_session_bind_all_unreserved_ports $var_git_session_bind_all_unreserved_ports
</fix><fix complexity="low" disruption="medium" reboot="false" rule="sssd_enable_smartcards" strategy="configure">
SSSD_CONF="/etc/sssd/sssd.conf"
SSSD_OPT="pam_cert_auth"
SSSD_OPT_VAL=true
PAM_REGEX="[[:space:]]*\[pam]"
PAM_OPT_REGEX="${PAM_REGEX}([^\n\[]*\n+)+?[[:space:]]*${SSSD_OPT}"

if grep -qzosP $PAM_OPT_REGEX $SSSD_CONF; then
	sed -i "s/${SSSD_OPT}[^(\n)]*/${SSSD_OPT} = ${SSSD_OPT_VAL}/" $SSSD_CONF
elif grep -qs $PAM_REGEX $SSSD_CONF; then
	sed -i "/$PAM_REGEX/a ${SSSD_OPT} = ${SSSD_OPT_VAL}" $SSSD_CONF
else
	mkdir -p /etc/sssd
	touch $SSSD_CONF
	echo -e "[pam]\n${SSSD_OPT} = ${SSSD_OPT_VAL}" &gt;&gt; $SSSD_CONF
fi
</fix><fix rule="audit_rules_system_shutdown">
# Traverse all of:
#
# /etc/audit/audit.rules,			(for auditctl case)
# /etc/audit/rules.d/*.rules			(for augenrules case)
#
# files to check if '-f .*' setting is present in that '*.rules' file already.
# If found, delete such occurrence since auditctl(8) manual page instructs the
# '-f 2' rule should be placed as the last rule in the configuration
find /etc/audit /etc/audit/rules.d -maxdepth 1 -type f -name '*.rules' -exec sed -i '/-e[[:space:]]\+.*/d' {} ';'

# Append '-f 2' requirement at the end of both:
# * /etc/audit/audit.rules file 		(for auditctl case)
# * /etc/audit/rules.d/immutable.rules		(for augenrules case)

for AUDIT_FILE in "/etc/audit/audit.rules" "/etc/audit/rules.d/immutable.rules"
do
	echo '' &gt;&gt; $AUDIT_FILE
	echo '# Set the audit.rules configuration to halt system upon audit failure per security requirements' &gt;&gt; $AUDIT_FILE
	echo '-f 2' &gt;&gt; $AUDIT_FILE
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_sys_script_anon_write" strategy="enable">
var_httpd_sys_script_anon_write="<sub idref="var_httpd_sys_script_anon_write" />"

setsebool -P httpd_sys_script_anon_write $var_httpd_sys_script_anon_write
</fix><fix reboot="false" rule="mount_option_tmp_noexec">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /tmp || { echo "Not remediating, because there is no record of /tmp in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/tmp" "noexec" "" ""

	ensure_partition_is_mounted "/tmp"
}

perform_remediation
</fix><fix rule="mount_option_krb_sec_remote_filesystems">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

ensure_mount_option_for_vfstype "nfs[4]?" "sec=krb5:krb5i:krb5p" "" "nfs4"
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_cron_monthly" strategy="configure">

chown 0 /etc/cron.monthly/
</fix><fix rule="accounts_max_concurrent_login_sessions">
var_accounts_max_concurrent_login_sessions="<sub idref="var_accounts_max_concurrent_login_sessions" />"

if grep -q '^[^#]*\&lt;maxlogins\&gt;' /etc/security/limits.d/*.conf; then
	sed -i "/^[^#]*\&lt;maxlogins\&gt;/ s/maxlogins.*/maxlogins $var_accounts_max_concurrent_login_sessions/" /etc/security/limits.d/*.conf
elif grep -q '^[^#]*\&lt;maxlogins\&gt;' /etc/security/limits.conf; then
	sed -i "/^[^#]*\&lt;maxlogins\&gt;/ s/maxlogins.*/maxlogins $var_accounts_max_concurrent_login_sessions/" /etc/security/limits.conf
else
	echo "*	hard	maxlogins	$var_accounts_max_concurrent_login_sessions" &gt;&gt; /etc/security/limits.conf
fi
</fix><fix rule="audit_rules_file_deletion_events_rmdir">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S rmdir.*"
	GROUP="delete"
	FULL_RULE="-a always,exit -F arch=$ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xguest_exec_content" strategy="enable">
var_xguest_exec_content="<sub idref="var_xguest_exec_content" />"

setsebool -P xguest_exec_content $var_xguest_exec_content
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_tty_comm" strategy="enable">
var_httpd_tty_comm="<sub idref="var_httpd_tty_comm" />"

setsebool -P httpd_tty_comm $var_httpd_tty_comm
</fix><fix complexity="low" disruption="low" reboot="false" rule="auditd_write_logs" strategy="restrict">if [ -e "/etc/audit/auditd.conf" ] ; then
    LC_ALL=C sed -i "/^\s*write_logs\s*=\s*/Id" "/etc/audit/auditd.conf"
else
    touch "/etc/audit/auditd.conf"
fi
cp "/etc/audit/auditd.conf" "/etc/audit/auditd.conf.bak"
# Insert at the end of the file
printf '%s\n' "write_logs = yes" &gt;&gt; "/etc/audit/auditd.conf"
# Clean up after ourselves.
rm "/etc/audit/auditd.conf.bak"
</fix><fix rule="configure_bind_crypto_policy">
function remediate_bind_crypto_policy() {
	CONFIG_FILE="/etc/named.conf"
	if test -f "$CONFIG_FILE"; then
		sed -i 's|options {|&amp;\n\tinclude "/etc/crypto-policies/back-ends/bind.config";|' "$CONFIG_FILE"
		return 0
	else
		echo "Aborting remediation as '$CONFIG_FILE' was not even found." &gt;&amp;2
		return 1
	fi
}

remediate_bind_crypto_policy
</fix><fix rule="ensure_logrotate_activated">
LOGROTATE_CONF_FILE="/etc/logrotate.conf"
CRON_DAILY_LOGROTATE_FILE="/etc/cron.daily/logrotate"

# daily rotation is configured
grep -q "^daily$" $LOGROTATE_CONF_FILE|| echo "daily" &gt;&gt; $LOGROTATE_CONF_FILE

# remove any line configuring weekly, monthly or yearly rotation
sed -i -r "/^(weekly|monthly|yearly)$/d" $LOGROTATE_CONF_FILE

# configure cron.daily if not already
if ! grep -q "^[[:space:]]*/usr/sbin/logrotate[[:alnum:][:blank:][:punct:]]*$LOGROTATE_CONF_FILE$" $CRON_DAILY_LOGROTATE_FILE; then
	echo "#!/bin/sh" &gt; $CRON_DAILY_LOGROTATE_FILE
	echo "/usr/sbin/logrotate $LOGROTATE_CONF_FILE" &gt;&gt; $CRON_DAILY_LOGROTATE_FILE
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_rsync_anon_write" strategy="enable">
var_rsync_anon_write="<sub idref="var_rsync_anon_write" />"

setsebool -P rsync_anon_write $var_rsync_anon_write
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_set_loglevel_info" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*LogLevel\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "LogLevel INFO" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "LogLevel INFO" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_named_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'named.service'
"$SYSTEMCTL_EXEC" disable 'named.service'
"$SYSTEMCTL_EXEC" mask 'named.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^named.socket'; then
    "$SYSTEMCTL_EXEC" stop 'named.socket'
    "$SYSTEMCTL_EXEC" disable 'named.socket'
    "$SYSTEMCTL_EXEC" mask 'named.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'named.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xserver_execmem" strategy="enable">
var_xserver_execmem="<sub idref="var_xserver_execmem" />"

setsebool -P xserver_execmem $var_xserver_execmem
</fix><fix rule="audit_rules_etc_shadow_open">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S open -F a1&amp;03 -F path=/etc/shadow.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S open -F a1&amp;03 -F path=/etc/shadow -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_tftp-server_removed" strategy="disable">
# CAUTION: This remediation script will remove tftp-server
#	   from the system, and may remove any packages
#	   that depend on tftp-server. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "tftp-server" ; then
    yum remove -y "tftp-server"
fi
</fix><fix rule="auditd_audispd_configure_remote_server">
var_audispd_remote_server="<sub idref="var_audispd_remote_server" />"


AUDITCONFIG=/etc/audit/audisp-remote.conf
<sub idref="function_replace_or_append" />
replace_or_append $AUDITCONFIG '^remote_server' "$var_audispd_remote_server" "@CCENUM@"
</fix><fix complexity="low" disruption="low" reboot="false" rule="network_nmcli_permissions" strategy="restrict">
printf "[Disable General User Access to NetworkManager]\nIdentity=default\nAction=org.freedesktop.NetworkManager.*\nResultAny=no\nResultInactive=no\nResultActive=auth_admin\n" &gt; /etc/polkit-1/localauthority/20-org.d/10-nm-harden-access.pkla
</fix><fix rule="accounts_passwords_pam_faillock_unlock_time">
var_accounts_passwords_pam_faillock_unlock_time="<sub idref="var_accounts_passwords_pam_faillock_unlock_time" />"

AUTH_FILES=("/etc/pam.d/system-auth" "/etc/pam.d/password-auth")

for pam_file in "${AUTH_FILES[@]}"
do
    # is auth required pam_faillock.so preauth present?
    if grep -qE '^\s*auth\s+required\s+pam_faillock\.so\s+preauth.*$' "$pam_file" ; then
        # is the option set?
        if grep -qE '^\s*auth\s+required\s+pam_faillock\.so\s+preauth.*'"unlock_time"'=([0-9]*).*$' "$pam_file" ; then
            # just change the value of option to a correct value
            sed -i --follow-symlinks 's/\(^auth.*required.*pam_faillock.so.*preauth.*silent.*\)\('"unlock_time"' *= *\).*/\1\2'"$var_accounts_passwords_pam_faillock_unlock_time"'/' "$pam_file"
        # the option is not set.
        else
            # append the option
            sed -i --follow-symlinks '/^auth.*required.*pam_faillock.so.*preauth.*silent.*/ s/$/ '"unlock_time"'='"$var_accounts_passwords_pam_faillock_unlock_time"'/' "$pam_file"
        fi
    # auth required pam_faillock.so preauth is not present, insert the whole line
    else
        sed -i --follow-symlinks '/^auth.*sufficient.*pam_unix.so.*/i auth        required      pam_faillock.so preauth silent '"unlock_time"'='"$var_accounts_passwords_pam_faillock_unlock_time" "$pam_file"
    fi
    # is auth default pam_faillock.so authfail present?
    if grep -qE '^\s*auth\s+(\[default=die\])\s+pam_faillock\.so\s+authfail.*$' "$pam_file" ; then
        # is the option set?
        if grep -qE '^\s*auth\s+(\[default=die\])\s+pam_faillock\.so\s+authfail.*'"unlock_time"'=([0-9]*).*$' "$pam_file" ; then
            # just change the value of option to a correct value
            sed -i --follow-symlinks 's/\(^auth.*[default=die].*pam_faillock.so.*authfail.*\)\('"unlock_time"' *= *\).*/\1\2'"$var_accounts_passwords_pam_faillock_unlock_time"'/' "$pam_file"
        # the option is not set.
        else
            # append the option
            sed -i --follow-symlinks '/^auth.*[default=die].*pam_faillock.so.*authfail.*/ s/$/ '"unlock_time"'='"$var_accounts_passwords_pam_faillock_unlock_time"'/' "$pam_file"
        fi
    # auth default pam_faillock.so authfail is not present, insert the whole line
    else
        sed -i --follow-symlinks '/^auth.*sufficient.*pam_unix.so.*/a auth        [default=die] pam_faillock.so authfail '"unlock_time"'='"$var_accounts_passwords_pam_faillock_unlock_time" "$pam_file"
    fi
    if ! grep -qE '^\s*account\s+required\s+pam_faillock\.so.*$' "$pam_file" ; then
        sed -E -i --follow-symlinks '/^\s*account\s*required\s*pam_unix.so/i account     required      pam_faillock.so' "$pam_file"
    fi
done
</fix><fix rule="audit_rules_privileged_commands_pam_timestamp_check">

PATTERN="-a always,exit -F path=/usr/sbin/pam_timestamp_check\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cups_execmem" strategy="enable">
var_cups_execmem="<sub idref="var_cups_execmem" />"

setsebool -P cups_execmem $var_cups_execmem
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_authlogin_yubikey" strategy="enable">
var_authlogin_yubikey="<sub idref="var_authlogin_yubikey" />"

setsebool -P authlogin_yubikey $var_authlogin_yubikey
</fix><fix complexity="high" disruption="medium" reboot="false" rule="rpm_verify_ownership" strategy="restrict">
# Declare array to hold set of RPM packages we need to correct permissions for
declare -A SETPERMS_RPM_DICT

# Create a list of files on the system having permissions different from what
# is expected by the RPM database
readarray -t FILES_WITH_INCORRECT_PERMS &lt; &lt;(rpm -Va --nofiledigest | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }')

for FILE_PATH in "${FILES_WITH_INCORRECT_PERMS[@]}"
do
        RPM_PACKAGE=$(rpm -qf "$FILE_PATH")
	# Use an associative array to store packages as it's keys, not having to care about duplicates.
	SETPERMS_RPM_DICT["$RPM_PACKAGE"]=1
done

# For each of the RPM packages left in the list -- reset its permissions to the
# correct values
for RPM_PACKAGE in "${!SETPERMS_RPM_DICT[@]}"
do
        rpm --setugids "${RPM_PACKAGE}"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_cron_hourly" strategy="configure">

chown 0 /etc/cron.hourly/
</fix><fix rule="audit_rules_unsuccessful_file_modification">

# Perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do

	# First fix the -EACCES requirement
	PATTERN="-a always,exit -F arch=$ARCH -S .* -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -k *"
	# Use escaped BRE regex to specify rule group
	GROUP="\(creat\|open\|truncate\)"
	FULL_RULE="-a always,exit -F arch=$ARCH -S creat -S open -S openat -S open_by_handle_at -S truncate -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -k access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"

	# Then fix the -EPERM requirement
	PATTERN="-a always,exit -F arch=$ARCH -S .* -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -k *"
	# No need to change content of $GROUP variable - it's the same as for -EACCES case above
	FULL_RULE="-a always,exit -F arch=$ARCH -S creat -S open -S openat -S open_by_handle_at -S truncate -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -k access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"

done
</fix><fix rule="sssd_memcache_timeout">
var_sssd_memcache_timeout="<sub idref="var_sssd_memcache_timeout" />"

SSSD_CONF="/etc/sssd/sssd.conf"
MEMCACHE_TIMEOUT_REGEX="[[:space:]]*\[nss]([^\n\[]*\n+)+?[[:space:]]*memcache_timeout"
NSS_REGEX="[[:space:]]*\[nss]"

# Try find [nss] and memcache_timeout in sssd.conf, if it exists, set to
# var_sssd_memcache_timeout, if it isn't here, add it, if [nss] doesn't
# exist, add it there
if grep -qzosP $MEMCACHE_TIMEOUT_REGEX $SSSD_CONF; then
        sed -i "s/memcache_timeout[^(\n)]*/memcache_timeout = $var_sssd_memcache_timeout/" $SSSD_CONF
elif grep -qs $NSS_REGEX $SSSD_CONF; then
        sed -i "/$NSS_REGEX/a memcache_timeout = $var_sssd_memcache_timeout" $SSSD_CONF
else
        mkdir -p /etc/sssd
        touch $SSSD_CONF
        echo -e "[nss]\nmemcache_timeout = $var_sssd_memcache_timeout" &gt;&gt; $SSSD_CONF
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mozilla_plugin_use_gps" strategy="enable">
var_mozilla_plugin_use_gps="<sub idref="var_mozilla_plugin_use_gps" />"

setsebool -P mozilla_plugin_use_gps $var_mozilla_plugin_use_gps
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mcelog_foreground" strategy="enable">
var_mcelog_foreground="<sub idref="var_mcelog_foreground" />"

setsebool -P mcelog_foreground $var_mcelog_foreground
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_sshd_pub_key" strategy="configure">
find /etc/ssh/ -regex '^.*.pub$' -exec chmod 0644 {} \;
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_icecast_use_any_tcp_ports" strategy="enable">
var_icecast_use_any_tcp_ports="<sub idref="var_icecast_use_any_tcp_ports" />"

setsebool -P icecast_use_any_tcp_ports $var_icecast_use_any_tcp_ports
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_abrt-plugin-logger_removed" strategy="disable">
# CAUTION: This remediation script will remove abrt-plugin-logger
#	   from the system, and may remove any packages
#	   that depend on abrt-plugin-logger. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "abrt-plugin-logger" ; then
    yum remove -y "abrt-plugin-logger"
fi
</fix><fix rule="audit_rules_privileged_commands_at">

PATTERN="-a always,exit -F path=/usr/bin/at\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/at -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="sysctl_kernel_exec_shield">

if [ "$(getconf LONG_BIT)" = "32" ] ; then
  #
  # Set runtime for kernel.exec-shield
  #
  sysctl -q -n -w kernel.exec-shield=1

  #
  # If kernel.exec-shield present in /etc/sysctl.conf, change value to "1"
  #	else, add "kernel.exec-shield = 1" to /etc/sysctl.conf
  #
<sub idref="function_replace_or_append" />
  replace_or_append '/etc/sysctl.conf' '^kernel.exec-shield' '1' '@CCENUM@'
fi

if [ "$(getconf LONG_BIT)" = "64" ] ; then
  if grep --silent noexec /boot/grub2/grub*.cfg ; then 
        sed -i "s/noexec.*//g" /etc/default/grub
        sed -i "s/noexec.*//g" /etc/grub.d/*
        GRUBCFG=/boot/grub2/*.cfg
        grub2-mkconfig -o "$GRUBCFG"
  fi
fi
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_all_accept_source_route" strategy="disable">
sysctl_net_ipv4_conf_all_accept_source_route_value="<sub idref="sysctl_net_ipv4_conf_all_accept_source_route_value" />"

#
# Set runtime for net.ipv4.conf.all.accept_source_route
#
/sbin/sysctl -q -n -w net.ipv4.conf.all.accept_source_route="$sysctl_net_ipv4_conf_all_accept_source_route_value"

#
# If net.ipv4.conf.all.accept_source_route present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.conf.all.accept_source_route = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.all.accept_source_route' "$sysctl_net_ipv4_conf_all_accept_source_route_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_smb_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'smb.service'
"$SYSTEMCTL_EXEC" disable 'smb.service'
"$SYSTEMCTL_EXEC" mask 'smb.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^smb.socket'; then
    "$SYSTEMCTL_EXEC" stop 'smb.socket'
    "$SYSTEMCTL_EXEC" disable 'smb.socket'
    "$SYSTEMCTL_EXEC" mask 'smb.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'smb.service' || true
</fix><fix rule="audit_rules_unsuccessful_file_modification_fchmod">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fchmod -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fchmod -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S fchmod -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S fchmod -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_can_network_connect_db" strategy="enable">
var_httpd_can_network_connect_db="<sub idref="var_httpd_can_network_connect_db" />"

setsebool -P httpd_can_network_connect_db $var_httpd_can_network_connect_db
</fix><fix complexity="low" disruption="low" reboot="false" rule="configure_usbguard_auditbackend" strategy="restrict">if [ -e "/etc/usbguard/usbguard-daemon.conf" ] ; then
    LC_ALL=C sed -i "/^\s*AuditBackend=/d" "/etc/usbguard/usbguard-daemon.conf"
else
    touch "/etc/usbguard/usbguard-daemon.conf"
fi
cp "/etc/usbguard/usbguard-daemon.conf" "/etc/usbguard/usbguard-daemon.conf.bak"
# Insert at the end of the file
printf '%s\n' "AuditBackend=LinuxAudit" &gt;&gt; "/etc/usbguard/usbguard-daemon.conf"
# Clean up after ourselves.
rm "/etc/usbguard/usbguard-daemon.conf.bak"
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_squashfs_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install squashfs" /etc/modprobe.d/squashfs.conf ; then
	sed -i 's/^install squashfs.*/install squashfs /bin/true/g' /etc/modprobe.d/squashfs.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/squashfs.conf
	echo "install squashfs /bin/true" &gt;&gt; /etc/modprobe.d/squashfs.conf
fi
</fix><fix reboot="false" rule="mount_option_noexec_removable_partitions">
var_removable_partition="<sub idref="var_removable_partition" />"
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab "$var_removable_partition" || { echo "Not remediating, because there is no record of $var_removable_partition in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "$var_removable_partition" "noexec" "" ""

	ensure_partition_is_mounted "$var_removable_partition"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_cron_d" strategy="configure">
chmod 0700 /etc/cron.d/
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_auditd_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'auditd.service'
"$SYSTEMCTL_EXEC" enable 'auditd.service'
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv6_conf_all_disable_ipv6" strategy="disable">

#
# Set runtime for net.ipv6.conf.all.disable_ipv6
#
/sbin/sysctl -q -n -w net.ipv6.conf.all.disable_ipv6="1"

#
# If net.ipv6.conf.all.disable_ipv6 present in /etc/sysctl.conf, change value to "1"
#	else, add "net.ipv6.conf.all.disable_ipv6 = 1" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv6.conf.all.disable_ipv6' "1" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rdisc_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rdisc.service'
"$SYSTEMCTL_EXEC" disable 'rdisc.service'
"$SYSTEMCTL_EXEC" mask 'rdisc.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rdisc.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rdisc.socket'
    "$SYSTEMCTL_EXEC" disable 'rdisc.socket'
    "$SYSTEMCTL_EXEC" mask 'rdisc.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rdisc.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_tftp_removed" strategy="disable">
# CAUTION: This remediation script will remove tftp
#	   from the system, and may remove any packages
#	   that depend on tftp. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "tftp" ; then
    yum remove -y "tftp"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="accounts_password_pam_dcredit" strategy="restrict">
var_password_pam_dcredit="<sub idref="var_password_pam_dcredit" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/security/pwquality.conf' '^dcredit' $var_password_pam_dcredit '@CCENUM@' '%s = %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_abrt_anon_write" strategy="enable">
var_abrt_anon_write="<sub idref="var_abrt_anon_write" />"

setsebool -P abrt_anon_write $var_abrt_anon_write
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_postgresql_connect_enabled" strategy="enable">
var_selinuxuser_postgresql_connect_enabled="<sub idref="var_selinuxuser_postgresql_connect_enabled" />"

setsebool -P selinuxuser_postgresql_connect_enabled $var_selinuxuser_postgresql_connect_enabled
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xdm_exec_bootloader" strategy="enable">
var_xdm_exec_bootloader="<sub idref="var_xdm_exec_bootloader" />"

setsebool -P xdm_exec_bootloader $var_xdm_exec_bootloader
</fix><fix rule="audit_rules_dac_modification_chmod">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S chmod.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="audit_rules_privileged_commands_umount">

PATTERN="-a always,exit -F path=/usr/bin/umount\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/umount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="audit_rules_unsuccessful_file_modification_fchmodat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fchmodat -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fchmodat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S fchmodat -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S fchmodat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_telepathy_connect_all_ports" strategy="enable">
var_telepathy_connect_all_ports="<sub idref="var_telepathy_connect_all_ports" />"

setsebool -P telepathy_connect_all_ports $var_telepathy_connect_all_ports
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_unconfined_login" strategy="enable">
var_unconfined_login="<sub idref="var_unconfined_login" />"

setsebool -P unconfined_login $var_unconfined_login
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_exim_read_user_files" strategy="enable">
var_exim_read_user_files="<sub idref="var_exim_read_user_files" />"

setsebool -P exim_read_user_files $var_exim_read_user_files
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_etc_group" strategy="configure">

chgrp 0 /etc/group
</fix><fix rule="audit_rules_dac_modification_fchown">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fchown.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_exim_manage_user_files" strategy="enable">
var_exim_manage_user_files="<sub idref="var_exim_manage_user_files" />"

setsebool -P exim_manage_user_files $var_exim_manage_user_files
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_ypbind_removed" strategy="disable">
# CAUTION: This remediation script will remove ypbind
#	   from the system, and may remove any packages
#	   that depend on ypbind. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "ypbind" ; then
    yum remove -y "ypbind"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_collectd_tcp_network_connect" strategy="enable">
var_collectd_tcp_network_connect="<sub idref="var_collectd_tcp_network_connect" />"

setsebool -P collectd_tcp_network_connect $var_collectd_tcp_network_connect
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_puppetagent_manage_all_files" strategy="enable">
var_puppetagent_manage_all_files="<sub idref="var_puppetagent_manage_all_files" />"

setsebool -P puppetagent_manage_all_files $var_puppetagent_manage_all_files
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_fenced_can_network_connect" strategy="enable">
var_fenced_can_network_connect="<sub idref="var_fenced_can_network_connect" />"

setsebool -P fenced_can_network_connect $var_fenced_can_network_connect
</fix><fix rule="dnf-automatic_apply_updates">
CONF="/etc/dnf/automatic.conf"
APPLY_UPDATES_REGEX="[[:space:]]*\[commands]([^\n\[]*\n+)+?[[:space:]]*apply_updates"
COMMANDS_REGEX="[[:space:]]*\[commands]"

# Try find [commands] and apply_updates in automatic.conf, if it exists, set
# to yes, if it isn't here, add it, if [commands] doesn't exist, add it there
if grep -qzosP $APPLY_UPDATES_REGEX $CONF; then
    sed -i "s/apply_updates[^(\n)]*/apply_updates = yes/" $CONF
elif grep -qs $COMMANDS_REGEX $CONF; then
    sed -i "/$COMMANDS_REGEX/a apply_updates = yes" $CONF
else
    mkdir -p /etc/dnf
    echo -e "[commands]\napply_updates = yes" &gt;&gt; $CONF
fi
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_icmp_ignore_bogus_error_responses" strategy="disable">
sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value="<sub idref="sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value" />"

#
# Set runtime for net.ipv4.icmp_ignore_bogus_error_responses
#
/sbin/sysctl -q -n -w net.ipv4.icmp_ignore_bogus_error_responses="$sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value"

#
# If net.ipv4.icmp_ignore_bogus_error_responses present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.icmp_ignore_bogus_error_responses = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.icmp_ignore_bogus_error_responses' "$sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_login_console_enabled" strategy="enable">
var_login_console_enabled="<sub idref="var_login_console_enabled" />"

setsebool -P login_console_enabled $var_login_console_enabled
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_named_write_master_zones" strategy="enable">
var_named_write_master_zones="<sub idref="var_named_write_master_zones" />"

setsebool -P named_write_master_zones $var_named_write_master_zones
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_kernel_yama_ptrace_scope" strategy="disable">

#
# Set runtime for kernel.yama.ptrace_scope
#
/sbin/sysctl -q -n -w kernel.yama.ptrace_scope="1"

#
# If kernel.yama.ptrace_scope present in /etc/sysctl.conf, change value to "1"
#	else, add "kernel.yama.ptrace_scope = 1" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^kernel.yama.ptrace_scope' "1" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_sssd_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'sssd.service'
"$SYSTEMCTL_EXEC" enable 'sssd.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_samba_share_nfs" strategy="enable">
var_samba_share_nfs="<sub idref="var_samba_share_nfs" />"

setsebool -P samba_share_nfs $var_samba_share_nfs
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_freevxfs_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install freevxfs" /etc/modprobe.d/freevxfs.conf ; then
	sed -i 's/^install freevxfs.*/install freevxfs /bin/true/g' /etc/modprobe.d/freevxfs.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/freevxfs.conf
	echo "install freevxfs /bin/true" &gt;&gt; /etc/modprobe.d/freevxfs.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_rsync_full_access" strategy="enable">
var_rsync_full_access="<sub idref="var_rsync_full_access" />"

setsebool -P rsync_full_access $var_rsync_full_access
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_transition_userdomain" strategy="enable">
var_virt_transition_userdomain="<sub idref="var_virt_transition_userdomain" />"

setsebool -P virt_transition_userdomain $var_virt_transition_userdomain
</fix><fix rule="file_ownership_binary_dirs">find /bin/ \
/usr/bin/ \
/usr/local/bin/ \
/sbin/ \
/usr/sbin/ \
/usr/local/sbin/ \
/usr/libexec \
\! -user root -execdir chown root {} \;
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_antivirus_can_scan_system" strategy="enable">
var_antivirus_can_scan_system="<sub idref="var_antivirus_can_scan_system" />"

setsebool -P antivirus_can_scan_system $var_antivirus_can_scan_system
</fix><fix rule="aide_use_fips_hashes">
if ! rpm -q --quiet "aide" ; then
    yum install -y "aide"
fi

aide_conf="/etc/aide.conf"
forbidden_hashes=(sha1 rmd160 sha256 whirlpool tiger haval gost crc32)

groups=$(LC_ALL=C grep "^[A-Z]\+" $aide_conf | cut -f1 -d ' ' | tr -d ' ' | sort -u)

for group in $groups
do
	config=$(grep "^$group\s*=" $aide_conf | cut -f2 -d '=' | tr -d ' ')

	if ! [[ $config = *sha512* ]]
	then
		config=$config"+sha512"
	fi

	for hash in ${forbidden_hashes[@]}
	do
		config=$(echo $config | sed "s/$hash//")
	done

	config=$(echo $config | sed "s/^\+*//")
	config=$(echo $config | sed "s/\+\++/+/")
	config=$(echo $config | sed "s/\+$//")

	sed -i "s/^$group\s*=.*/$group = $config/g" $aide_conf
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_telnet-server_removed" strategy="disable">
# CAUTION: This remediation script will remove telnet-server
#	   from the system, and may remove any packages
#	   that depend on telnet-server. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "telnet-server" ; then
    yum remove -y "telnet-server"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_logrotate_use_nfs" strategy="enable">
var_logrotate_use_nfs="<sub idref="var_logrotate_use_nfs" />"

setsebool -P logrotate_use_nfs $var_logrotate_use_nfs
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_geolite2-city_removed" strategy="disable">
# CAUTION: This remediation script will remove geolite2-city
#	   from the system, and may remove any packages
#	   that depend on geolite2-city. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "geolite2-city" ; then
    yum remove -y "geolite2-city"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_samba_export_all_rw" strategy="enable">
var_samba_export_all_rw="<sub idref="var_samba_export_all_rw" />"

setsebool -P samba_export_all_rw $var_samba_export_all_rw
</fix><fix rule="rsyslog_cron_logging">
if ! grep -s "^\s*cron\.\*\s*/var/log/cron$" /etc/rsyslog.conf /etc/rsyslog.d/*.conf; then
	mkdir -p /etc/rsyslog.d
	echo "cron.*	/var/log/cron" &gt;&gt; /etc/rsyslog.d/cron.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_ntpdate_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'ntpdate.service'
"$SYSTEMCTL_EXEC" disable 'ntpdate.service'
"$SYSTEMCTL_EXEC" mask 'ntpdate.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^ntpdate.socket'; then
    "$SYSTEMCTL_EXEC" stop 'ntpdate.socket'
    "$SYSTEMCTL_EXEC" disable 'ntpdate.socket'
    "$SYSTEMCTL_EXEC" mask 'ntpdate.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'ntpdate.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_atd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'atd.service'
"$SYSTEMCTL_EXEC" disable 'atd.service'
"$SYSTEMCTL_EXEC" mask 'atd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^atd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'atd.socket'
    "$SYSTEMCTL_EXEC" disable 'atd.socket'
    "$SYSTEMCTL_EXEC" mask 'atd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'atd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_daemons_enable_cluster_mode" strategy="enable">
var_daemons_enable_cluster_mode="<sub idref="var_daemons_enable_cluster_mode" />"

setsebool -P daemons_enable_cluster_mode $var_daemons_enable_cluster_mode
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_dhcpd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'dhcpd.service'
"$SYSTEMCTL_EXEC" disable 'dhcpd.service'
"$SYSTEMCTL_EXEC" mask 'dhcpd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^dhcpd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'dhcpd.socket'
    "$SYSTEMCTL_EXEC" disable 'dhcpd.socket'
    "$SYSTEMCTL_EXEC" mask 'dhcpd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'dhcpd.service' || true
</fix><fix rule="set_password_hashing_algorithm_systemauth">
AUTH_FILES[0]="/etc/pam.d/system-auth"
AUTH_FILES[1]="/etc/pam.d/password-auth"

for pamFile in "${AUTH_FILES[@]}"
do
	if ! grep -q "^password.*sufficient.*pam_unix.so.*sha512" $pamFile; then
		sed -i --follow-symlinks "/^password.*sufficient.*pam_unix.so/ s/$/ sha512/" $pamFile
	fi
done
</fix><fix rule="grub2_enable_selinux">
</fix><fix rule="audit_rules_etc_passwd_openat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S openat -F a2&amp;03 -F path=/etc/passwd.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S openat -F a2&amp;03 -F path=/etc/passwd -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rngd_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'rngd.service'
"$SYSTEMCTL_EXEC" enable 'rngd.service'
</fix><fix rule="audit_rules_unsuccessful_file_modification_creat">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_can_network_memcache" strategy="enable">
var_httpd_can_network_memcache="<sub idref="var_httpd_can_network_memcache" />"

setsebool -P httpd_can_network_memcache $var_httpd_can_network_memcache
</fix><fix rule="no_user_host_based_files">
# Identify local mounts
MOUNT_LIST=$(df --local | awk '{ print $6 }')

# Find file on each listed mount point
for cur_mount in ${MOUNT_LIST}
do
	find ${cur_mount} -xdev -type f -name ".shosts" -exec rm -f {} \;
done
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_core_bpf_jit_harden" strategy="disable">

#
# Set runtime for net.core.bpf_jit_harden
#
/sbin/sysctl -q -n -w net.core.bpf_jit_harden="2"

#
# If net.core.bpf_jit_harden present in /etc/sysctl.conf, change value to "2"
#	else, add "net.core.bpf_jit_harden = 2" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.core.bpf_jit_harden' "2" '@CCENUM@'
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_jffs2_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install jffs2" /etc/modprobe.d/jffs2.conf ; then
	sed -i 's/^install jffs2.*/install jffs2 /bin/true/g' /etc/modprobe.d/jffs2.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/jffs2.conf
	echo "install jffs2 /bin/true" &gt;&gt; /etc/modprobe.d/jffs2.conf
fi
</fix><fix rule="audit_rules_unsuccessful_file_modification_open_o_trunc_write">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix rule="audit_rules_unsuccessful_file_modification_open">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_nscd_use_shm" strategy="enable">
var_nscd_use_shm="<sub idref="var_nscd_use_shm" />"

setsebool -P nscd_use_shm $var_nscd_use_shm
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mock_enable_homedirs" strategy="enable">
var_mock_enable_homedirs="<sub idref="var_mock_enable_homedirs" />"

setsebool -P mock_enable_homedirs $var_mock_enable_homedirs
</fix><fix rule="audit_rules_login_events_faillock">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/var/run/faillock" "wa" "logins"
fix_audit_watch_rule "augenrules" "/var/run/faillock" "wa" "logins"
</fix><fix rule="audit_rules_unsuccessful_file_modification_open_rule_order">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_dccp_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install dccp" /etc/modprobe.d/dccp.conf ; then
	sed -i 's/^install dccp.*/install dccp /bin/true/g' /etc/modprobe.d/dccp.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/dccp.conf
	echo "install dccp /bin/true" &gt;&gt; /etc/modprobe.d/dccp.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_tmpreaper_use_samba" strategy="enable">
var_tmpreaper_use_samba="<sub idref="var_tmpreaper_use_samba" />"

setsebool -P tmpreaper_use_samba $var_tmpreaper_use_samba
</fix><fix rule="audit_rules_privileged_commands_sudo">

PATTERN="-a always,exit -F path=/usr/bin/sudo\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="audit_rules_privileged_commands_ssh_keysign">

PATTERN="-a always,exit -F path=/usr/libexec/openssh/ssh-keysign\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/libexec/openssh/ssh-keysign -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mcelog_server" strategy="enable">
var_mcelog_server="<sub idref="var_mcelog_server" />"

setsebool -P mcelog_server $var_mcelog_server
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_abrt_upload_watch_anon_write" strategy="enable">
var_abrt_upload_watch_anon_write="<sub idref="var_abrt_upload_watch_anon_write" />"

setsebool -P abrt_upload_watch_anon_write $var_abrt_upload_watch_anon_write
</fix><fix reboot="false" rule="mount_option_var_log_nosuid">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/log || { echo "Not remediating, because there is no record of /var/log in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/log" "nosuid" "" ""

	ensure_partition_is_mounted "/var/log"
}

perform_remediation
</fix><fix rule="configure_libreswan_crypto_policy">
function remediate_libreswan_crypto_policy() {
    CONFIG_FILE="/etc/ipsec.conf"
    if ! grep -qP "^\s*include\s+/etc/crypto-policies/back-ends/libreswan.config\s*(?:#.*)?$" "$CONFIG_FILE" ; then
        echo 'include /etc/crypto-policies/back-ends/libreswan.config' &gt;&gt; "$CONFIG_FILE"
    fi
    return 0
}

remediate_libreswan_crypto_policy
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_secure_mode" strategy="enable">
var_secure_mode="<sub idref="var_secure_mode" />"

setsebool -P secure_mode $var_secure_mode
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_fs_protected_hardlinks" strategy="disable">

#
# Set runtime for fs.protected_hardlinks
#
/sbin/sysctl -q -n -w fs.protected_hardlinks="1"

#
# If fs.protected_hardlinks present in /etc/sysctl.conf, change value to "1"
#	else, add "fs.protected_hardlinks = 1" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^fs.protected_hardlinks' "1" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_authlogin_radius" strategy="enable">
var_authlogin_radius="<sub idref="var_authlogin_radius" />"

setsebool -P authlogin_radius $var_authlogin_radius
</fix><fix reboot="false" rule="mount_option_dev_shm_nosuid">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "no" = 'yes'; then
		assert_mount_point_in_fstab /dev/shm || { echo "Not remediating, because there is no record of /dev/shm in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/dev/shm" "nosuid" "tmpfs" "tmpfs"

	ensure_partition_is_mounted "/dev/shm"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_squid_removed" strategy="disable">
# CAUTION: This remediation script will remove squid
#	   from the system, and may remove any packages
#	   that depend on squid. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "squid" ; then
    yum remove -y "squid"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_git_cgi_use_nfs" strategy="enable">
var_git_cgi_use_nfs="<sub idref="var_git_cgi_use_nfs" />"

setsebool -P git_cgi_use_nfs $var_git_cgi_use_nfs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_enable_strictmodes" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*StrictModes\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "StrictModes yes" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "StrictModes yes" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_tftp_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'tftp.service'
"$SYSTEMCTL_EXEC" disable 'tftp.service'
"$SYSTEMCTL_EXEC" mask 'tftp.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^tftp.socket'; then
    "$SYSTEMCTL_EXEC" stop 'tftp.socket'
    "$SYSTEMCTL_EXEC" disable 'tftp.socket'
    "$SYSTEMCTL_EXEC" mask 'tftp.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'tftp.service' || true
</fix><fix rule="mount_option_var_tmp_bind">

# Delete particular /etc/fstab's row if /var/tmp is already configured to
# represent a mount point (for some device or filesystem other than /tmp)
if grep -q -P '.*\/var\/tmp.*' /etc/fstab
then
  sed -i '/.*\/var\/tmp.*/d' /etc/fstab
fi
umount /var/tmp

# Bind-mount /var/tmp to /tmp via /etc/fstab (preserving the /etc/fstab form)
printf "%-24s%-24s%-8s%-32s%-3s\n" "/tmp" "/var/tmp" "none" "rw,nodev,noexec,nosuid,bind" "0 0" &gt;&gt; /etc/fstab

mkdir -p /var/tmp
mount -B /tmp /var/tmp
</fix><fix rule="dconf_gnome_login_retries">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/login-screen\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db//"
DBDIR="/etc/dconf/db/"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/login-screen]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "allowed-failures3gdm.d" "00-security-settings" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "00-security-settings")"
    if grep -q "^\\s*allowed-failures3gdm.d" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*allowed-failures3gdm.d\\s*=\\s*.*/allowed-failures3gdm.d=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/login-screen\\]|a\\allowed-failures3gdm.d=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/login-screen/allowed-failures$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/gdm.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/login-screen/allowed-failures" &gt;&gt; "/etc/dconf/db/gdm.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_git_system_enable_homedirs" strategy="enable">
var_git_system_enable_homedirs="<sub idref="var_git_system_enable_homedirs" />"

setsebool -P git_system_enable_homedirs $var_git_system_enable_homedirs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_enable_x11_forwarding" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*X11Forwarding\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "X11Forwarding yes" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "X11Forwarding yes" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix rule="mount_option_nosuid_remote_filesystems">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

ensure_mount_option_for_vfstype "nfs[4]?" "nosuid" "" "nfs4"
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_cron_allow" strategy="configure">

chown 0 /etc/cron.allow
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_nails_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'nails.service'
"$SYSTEMCTL_EXEC" enable 'nails.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_udp_server" strategy="enable">
var_selinuxuser_udp_server="<sub idref="var_selinuxuser_udp_server" />"

setsebool -P selinuxuser_udp_server $var_selinuxuser_udp_server
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_dovecot_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'dovecot.service'
"$SYSTEMCTL_EXEC" disable 'dovecot.service'
"$SYSTEMCTL_EXEC" mask 'dovecot.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^dovecot.socket'; then
    "$SYSTEMCTL_EXEC" stop 'dovecot.socket'
    "$SYSTEMCTL_EXEC" disable 'dovecot.socket'
    "$SYSTEMCTL_EXEC" mask 'dovecot.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'dovecot.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_abrtd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'abrtd.service'
"$SYSTEMCTL_EXEC" disable 'abrtd.service'
"$SYSTEMCTL_EXEC" mask 'abrtd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^abrtd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'abrtd.socket'
    "$SYSTEMCTL_EXEC" disable 'abrtd.socket'
    "$SYSTEMCTL_EXEC" mask 'abrtd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'abrtd.service' || true
</fix><fix reboot="false" rule="mount_option_var_nodev">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var || { echo "Not remediating, because there is no record of /var in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var" "nodev" "" ""

	ensure_partition_is_mounted "/var"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_ypbind_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'ypbind.service'
"$SYSTEMCTL_EXEC" disable 'ypbind.service'
"$SYSTEMCTL_EXEC" mask 'ypbind.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^ypbind.socket'; then
    "$SYSTEMCTL_EXEC" stop 'ypbind.socket'
    "$SYSTEMCTL_EXEC" disable 'ypbind.socket'
    "$SYSTEMCTL_EXEC" mask 'ypbind.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'ypbind.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_use_nfs" strategy="enable">
var_virt_use_nfs="<sub idref="var_virt_use_nfs" />"

setsebool -P virt_use_nfs $var_virt_use_nfs
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_sssd-ipa_installed" strategy="enable">
if ! rpm -q --quiet "sssd-ipa" ; then
    yum install -y "sssd-ipa"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_syslogng_installed" strategy="enable">
if ! rpm -q --quiet "syslogng" ; then
    yum install -y "syslogng"
fi
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_atm_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install atm" /etc/modprobe.d/atm.conf ; then
	sed -i 's/^install atm.*/install atm /bin/true/g' /etc/modprobe.d/atm.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/atm.conf
	echo "install atm /bin/true" &gt;&gt; /etc/modprobe.d/atm.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xen_use_nfs" strategy="enable">
var_xen_use_nfs="<sub idref="var_xen_use_nfs" />"

setsebool -P xen_use_nfs $var_xen_use_nfs
</fix><fix rule="audit_rules_session_events">

# Perform the remediation
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/var/run/utmp" "wa" "session"
fix_audit_watch_rule "augenrules" "/var/run/utmp" "wa" "session"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/var/log/btmp" "wa" "session"
fix_audit_watch_rule "augenrules" "/var/log/btmp" "wa" "session"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/var/log/wtmp" "wa" "session"
fix_audit_watch_rule "augenrules" "/var/log/wtmp" "wa" "session"
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_xinetd_removed" strategy="disable">
# CAUTION: This remediation script will remove xinetd
#	   from the system, and may remove any packages
#	   that depend on xinetd. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "xinetd" ; then
    yum remove -y "xinetd"
fi
</fix><fix rule="audit_rules_privileged_commands_mount">

PATTERN="-a always,exit -F path=/usr/bin/mount\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/mount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_cups_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'cups.service'
"$SYSTEMCTL_EXEC" disable 'cups.service'
"$SYSTEMCTL_EXEC" mask 'cups.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^cups.socket'; then
    "$SYSTEMCTL_EXEC" stop 'cups.socket'
    "$SYSTEMCTL_EXEC" disable 'cups.socket'
    "$SYSTEMCTL_EXEC" mask 'cups.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'cups.service' || true
</fix><fix rule="accounts_password_pam_unix_remember">
var_password_pam_unix_remember="<sub idref="var_password_pam_unix_remember" />"

AUTH_FILES[0]="/etc/pam.d/system-auth"
AUTH_FILES[1]="/etc/pam.d/password-auth"

for pamFile in "${AUTH_FILES[@]}"
do
	if grep -q "remember=" $pamFile; then
		sed -i --follow-symlinks "s/\(^password.*sufficient.*pam_unix.so.*\)\(\(remember *= *\)[^ $]*\)/\1remember=$var_password_pam_unix_remember/" $pamFile
	else
		sed -i --follow-symlinks "/^password[[:space:]]\+sufficient[[:space:]]\+pam_unix.so/ s/$/ remember=$var_password_pam_unix_remember/" $pamFile
	fi
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_irqbalance_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'irqbalance.service'
"$SYSTEMCTL_EXEC" enable 'irqbalance.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_tor_can_network_relay" strategy="enable">
var_tor_can_network_relay="<sub idref="var_tor_can_network_relay" />"

setsebool -P tor_can_network_relay $var_tor_can_network_relay
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_net-snmp_removed" strategy="disable">
# CAUTION: This remediation script will remove net-snmp
#	   from the system, and may remove any packages
#	   that depend on net-snmp. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "net-snmp" ; then
    yum remove -y "net-snmp"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_dhcp_removed" strategy="disable">
# CAUTION: This remediation script will remove dhcp
#	   from the system, and may remove any packages
#	   that depend on dhcp. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "dhcp" ; then
    yum remove -y "dhcp"
fi
</fix><fix rule="dconf_gnome_session_idle_user_locks">

# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/session/idle-delay$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/session/idle-delay" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix rule="dconf_gnome_disable_thumbnailers">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/desktop/thumbnailers\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/desktop/thumbnailers]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "disable-all" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*disable-all" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*disable-all\\s*=\\s*.*/disable-all=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/desktop/thumbnailers\\]|a\\disable-all=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/thumbnailers/disable-all$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/thumbnailers/disable-all" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_default_log_martians" strategy="disable">
sysctl_net_ipv4_conf_default_log_martians_value="<sub idref="sysctl_net_ipv4_conf_default_log_martians_value" />"

#
# Set runtime for net.ipv4.conf.default.log_martians
#
/sbin/sysctl -q -n -w net.ipv4.conf.default.log_martians="$sysctl_net_ipv4_conf_default_log_martians_value"

#
# If net.ipv4.conf.default.log_martians present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.conf.default.log_martians = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.default.log_martians' "$sysctl_net_ipv4_conf_default_log_martians_value" '@CCENUM@'
</fix><fix rule="selinux_state">
var_selinux_state="<sub idref="var_selinux_state" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysconfig/selinux' '^SELINUX=' $var_selinux_state '@CCENUM@' '%s=%s'

fixfiles onboot
fixfiles -f relabel
</fix><fix reboot="false" rule="mount_option_var_log_audit_noexec">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/log/audit || { echo "Not remediating, because there is no record of /var/log/audit in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/log/audit" "noexec" "" ""

	ensure_partition_is_mounted "/var/log/audit"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_httpd_removed" strategy="disable">
# CAUTION: This remediation script will remove httpd
#	   from the system, and may remove any packages
#	   that depend on httpd. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "httpd" ; then
    yum remove -y "httpd"
fi
</fix><fix rule="account_disable_post_pw_expiration">
var_account_disable_post_pw_expiration="<sub idref="var_account_disable_post_pw_expiration" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/default/useradd' '^INACTIVE' "$var_account_disable_post_pw_expiration" '@CCENUM@' '%s=%s'
</fix><fix rule="audit_rules_file_deletion_events_rename">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S rename.*"
	GROUP="delete"
	FULL_RULE="-a always,exit -F arch=$ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="audit_rules_unsuccessful_file_modification_openat_o_trunc_write">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_glance_use_fusefs" strategy="enable">
var_glance_use_fusefs="<sub idref="var_glance_use_fusefs" />"

setsebool -P glance_use_fusefs $var_glance_use_fusefs
</fix><fix rule="file_permissions_library_dirs">DIRS="/lib /lib64 /usr/lib /usr/lib64"
for dirPath in $DIRS; do
	find "$dirPath" -perm /022 -type f -exec chmod go-w '{}' \;
done
</fix><fix rule="dir_perms_world_writable_sticky_bits">df --local -P | awk '{if (NR!=1) print $6}' \
| xargs -I '{}' find '{}' -xdev -type d \
\( -perm -0002 -a ! -perm -1000 \) 2&gt;/dev/null \
| xargs chmod a+t
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_daemons_use_tcp_wrapper" strategy="enable">
var_daemons_use_tcp_wrapper="<sub idref="var_daemons_use_tcp_wrapper" />"

setsebool -P daemons_use_tcp_wrapper $var_daemons_use_tcp_wrapper
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_irssi_use_full_network" strategy="enable">
var_irssi_use_full_network="<sub idref="var_irssi_use_full_network" />"

setsebool -P irssi_use_full_network $var_irssi_use_full_network
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_crontab" strategy="configure">

chown 0 /etc/crontab
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_sshd_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'sshd.service'
"$SYSTEMCTL_EXEC" enable 'sshd.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="auditd_log_format" strategy="restrict">if [ -e "/etc/audit/auditd.conf" ] ; then
    LC_ALL=C sed -i "/^\s*log_format\s*=\s*/Id" "/etc/audit/auditd.conf"
else
    touch "/etc/audit/auditd.conf"
fi
cp "/etc/audit/auditd.conf" "/etc/audit/auditd.conf.bak"
# Insert at the end of the file
printf '%s\n' "log_format = ENRICHED" &gt;&gt; "/etc/audit/auditd.conf"
# Clean up after ourselves.
rm "/etc/audit/auditd.conf.bak"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_nfsd_anon_write" strategy="enable">
var_nfsd_anon_write="<sub idref="var_nfsd_anon_write" />"

setsebool -P nfsd_anon_write $var_nfsd_anon_write
</fix><fix rule="auditd_data_retention_max_log_file">
var_auditd_max_log_file="<sub idref="var_auditd_max_log_file" />"

AUDITCONFIG=/etc/audit/auditd.conf
<sub idref="function_replace_or_append" />
replace_or_append $AUDITCONFIG '^max_log_file' "$var_auditd_max_log_file" "@CCENUM@"
</fix><fix rule="audit_rules_unsuccessful_file_modification_setxattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S setxattr -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S setxattr -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S setxattr -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S setxattr -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_zoneminder_anon_write" strategy="enable">
var_zoneminder_anon_write="<sub idref="var_zoneminder_anon_write" />"

setsebool -P zoneminder_anon_write $var_zoneminder_anon_write
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_staff_exec_content" strategy="enable">
var_staff_exec_content="<sub idref="var_staff_exec_content" />"

setsebool -P staff_exec_content $var_staff_exec_content
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_openldap-servers_removed" strategy="disable">
# CAUTION: This remediation script will remove openldap-servers
#	   from the system, and may remove any packages
#	   that depend on openldap-servers. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "openldap-servers" ; then
    yum remove -y "openldap-servers"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_read_qemu_ga_data" strategy="enable">
var_virt_read_qemu_ga_data="<sub idref="var_virt_read_qemu_ga_data" />"

setsebool -P virt_read_qemu_ga_data $var_virt_read_qemu_ga_data
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_openvpn_can_network_connect" strategy="enable">
var_openvpn_can_network_connect="<sub idref="var_openvpn_can_network_connect" />"

setsebool -P openvpn_can_network_connect $var_openvpn_can_network_connect
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_scap-security-guide_installed" strategy="enable">
if ! rpm -q --quiet "scap-security-guide" ; then
    yum install -y "scap-security-guide"
fi
</fix><fix rule="audit_rules_privileged_commands_pt_chown">

PATTERN="-a always,exit -F path=/usr/libexec/pt_chown\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/libexec/pt_chown -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="audit_rules_unsuccessful_file_modification_open_by_handle_at_o_trunc_write">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_cron_daily" strategy="configure">

chown 0 /etc/cron.daily/
</fix><fix complexity="low" disruption="low" reboot="false" rule="auditd_name_format" strategy="restrict">if [ -e "/etc/audit/auditd.conf" ] ; then
    LC_ALL=C sed -i "/^\s*name_format\s*=\s*/Id" "/etc/audit/auditd.conf"
else
    touch "/etc/audit/auditd.conf"
fi
cp "/etc/audit/auditd.conf" "/etc/audit/auditd.conf.bak"
# Insert at the end of the file
printf '%s\n' "name_format = hostname" &gt;&gt; "/etc/audit/auditd.conf"
# Clean up after ourselves.
rm "/etc/audit/auditd.conf.bak"
</fix><fix rule="audit_rules_kernel_module_loading_finit">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
# Note: 32-bit and 64-bit kernel syscall numbers not always line up =&gt;
#       it's required on a 64-bit system to check also for the presence
#       of 32-bit's equivalent of the corresponding rule.
#       (See `man 7 audit.rules` for details )
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S finit_module \(-F key=\|-k \).*"
	GROUP="modules"
	FULL_RULE="-a always,exit -F arch=$ARCH -S finit_module -k modules"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_openvpn_run_unconfined" strategy="enable">
var_openvpn_run_unconfined="<sub idref="var_openvpn_run_unconfined" />"

setsebool -P openvpn_run_unconfined $var_openvpn_run_unconfined
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_cgconfig_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'cgconfig.service'
"$SYSTEMCTL_EXEC" disable 'cgconfig.service'
"$SYSTEMCTL_EXEC" mask 'cgconfig.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^cgconfig.socket'; then
    "$SYSTEMCTL_EXEC" stop 'cgconfig.socket'
    "$SYSTEMCTL_EXEC" disable 'cgconfig.socket'
    "$SYSTEMCTL_EXEC" mask 'cgconfig.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'cgconfig.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_dontaudit_search_dirs" strategy="enable">
var_httpd_dontaudit_search_dirs="<sub idref="var_httpd_dontaudit_search_dirs" />"

setsebool -P httpd_dontaudit_search_dirs $var_httpd_dontaudit_search_dirs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_named_tcp_bind_http_port" strategy="enable">
var_named_tcp_bind_http_port="<sub idref="var_named_tcp_bind_http_port" />"

setsebool -P named_tcp_bind_http_port $var_named_tcp_bind_http_port
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_etc_shadow" strategy="configure">

chgrp 0 /etc/shadow
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_logging_syslogd_use_tty" strategy="enable">
var_logging_syslogd_use_tty="<sub idref="var_logging_syslogd_use_tty" />"

setsebool -P logging_syslogd_use_tty $var_logging_syslogd_use_tty
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_use_fusefs" strategy="enable">
var_virt_use_fusefs="<sub idref="var_virt_use_fusefs" />"

setsebool -P virt_use_fusefs $var_virt_use_fusefs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_use_comm" strategy="enable">
var_virt_use_comm="<sub idref="var_virt_use_comm" />"

setsebool -P virt_use_comm $var_virt_use_comm
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_use_sanlock" strategy="enable">
var_virt_use_sanlock="<sub idref="var_virt_use_sanlock" />"

setsebool -P virt_use_sanlock $var_virt_use_sanlock
</fix><fix rule="require_emergency_target_auth">
service_file="/usr/lib/systemd/system/emergency.service"

sulogin="/usr/lib/systemd/systemd-sulogin-shell emergency"

if grep "^ExecStart=.*" "$service_file" ; then
    sed -i "s%^ExecStart=.*%ExecStart=-$sulogin%" "$service_file"
else
    echo "ExecStart=-$sulogin" &gt;&gt; "$service_file"
fi
</fix><fix reboot="false" rule="mount_option_var_log_audit_nodev">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/log/audit || { echo "Not remediating, because there is no record of /var/log/audit in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/log/audit" "nodev" "" ""

	ensure_partition_is_mounted "/var/log/audit"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rpcsvcgssd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rpcsvcgssd.service'
"$SYSTEMCTL_EXEC" disable 'rpcsvcgssd.service'
"$SYSTEMCTL_EXEC" mask 'rpcsvcgssd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rpcsvcgssd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rpcsvcgssd.socket'
    "$SYSTEMCTL_EXEC" disable 'rpcsvcgssd.socket'
    "$SYSTEMCTL_EXEC" mask 'rpcsvcgssd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rpcsvcgssd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_messagebus_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'messagebus.service'
"$SYSTEMCTL_EXEC" disable 'messagebus.service'
"$SYSTEMCTL_EXEC" mask 'messagebus.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^messagebus.socket'; then
    "$SYSTEMCTL_EXEC" stop 'messagebus.socket'
    "$SYSTEMCTL_EXEC" disable 'messagebus.socket'
    "$SYSTEMCTL_EXEC" mask 'messagebus.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'messagebus.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_cron_d" strategy="configure">

chgrp 0 /etc/cron.d/
</fix><fix complexity="low" disruption="low" reboot="false" rule="accounts_password_pam_ocredit" strategy="restrict">
var_password_pam_ocredit="<sub idref="var_password_pam_ocredit" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/security/pwquality.conf' '^ocredit' $var_password_pam_ocredit '@CCENUM@' '%s = %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_enable_ftp_server" strategy="enable">
var_httpd_enable_ftp_server="<sub idref="var_httpd_enable_ftp_server" />"

setsebool -P httpd_enable_ftp_server $var_httpd_enable_ftp_server
</fix><fix rule="audit_rules_etc_group_openat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S openat -F a2&amp;03 -F path=/etc/group.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S openat -F a2&amp;03 -F path=/etc/group -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_guest_exec_content" strategy="enable">
var_guest_exec_content="<sub idref="var_guest_exec_content" />"

setsebool -P guest_exec_content $var_guest_exec_content
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_telnet_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'telnet.service'
"$SYSTEMCTL_EXEC" disable 'telnet.service'
"$SYSTEMCTL_EXEC" mask 'telnet.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^telnet.socket'; then
    "$SYSTEMCTL_EXEC" stop 'telnet.socket'
    "$SYSTEMCTL_EXEC" disable 'telnet.socket'
    "$SYSTEMCTL_EXEC" mask 'telnet.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'telnet.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mpd_use_cifs" strategy="enable">
var_mpd_use_cifs="<sub idref="var_mpd_use_cifs" />"

setsebool -P mpd_use_cifs $var_mpd_use_cifs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cvs_read_shadow" strategy="enable">
var_cvs_read_shadow="<sub idref="var_cvs_read_shadow" />"

setsebool -P cvs_read_shadow $var_cvs_read_shadow
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_abrt_handle_event" strategy="enable">
var_abrt_handle_event="<sub idref="var_abrt_handle_event" />"

setsebool -P abrt_handle_event $var_abrt_handle_event
</fix><fix rule="no_empty_passwords">sed --follow-symlinks -i 's/\&lt;nullok\&gt;//g' /etc/pam.d/system-auth
sed --follow-symlinks -i 's/\&lt;nullok\&gt;//g' /etc/pam.d/password-auth
</fix><fix complexity="low" disruption="low" reboot="false" rule="auditd_local_events" strategy="restrict">if [ -e "/etc/audit/auditd.conf" ] ; then
    LC_ALL=C sed -i "/^\s*local_events\s*=\s*/Id" "/etc/audit/auditd.conf"
else
    touch "/etc/audit/auditd.conf"
fi
cp "/etc/audit/auditd.conf" "/etc/audit/auditd.conf.bak"
# Insert at the end of the file
printf '%s\n' "local_events = yes" &gt;&gt; "/etc/audit/auditd.conf"
# Clean up after ourselves.
rm "/etc/audit/auditd.conf.bak"
</fix><fix rule="audit_rules_privileged_commands_passwd">

PATTERN="-a always,exit -F path=/usr/bin/passwd\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_bluetooth_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install bluetooth" /etc/modprobe.d/bluetooth.conf ; then
	sed -i 's/^install bluetooth.*/install bluetooth /bin/true/g' /etc/modprobe.d/bluetooth.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/bluetooth.conf
	echo "install bluetooth /bin/true" &gt;&gt; /etc/modprobe.d/bluetooth.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_vsftpd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'vsftpd.service'
"$SYSTEMCTL_EXEC" disable 'vsftpd.service'
"$SYSTEMCTL_EXEC" mask 'vsftpd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^vsftpd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'vsftpd.socket'
    "$SYSTEMCTL_EXEC" disable 'vsftpd.socket'
    "$SYSTEMCTL_EXEC" mask 'vsftpd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'vsftpd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_unconfined_mozilla_plugin_transition" strategy="enable">
var_unconfined_mozilla_plugin_transition="<sub idref="var_unconfined_mozilla_plugin_transition" />"

setsebool -P unconfined_mozilla_plugin_transition $var_unconfined_mozilla_plugin_transition
</fix><fix rule="audit_rules_usergroup_modification_group">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/group" "wa" "audit_rules_usergroup_modification"
fix_audit_watch_rule "augenrules" "/etc/group" "wa" "audit_rules_usergroup_modification"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_smbd_anon_write" strategy="enable">
var_smbd_anon_write="<sub idref="var_smbd_anon_write" />"

setsebool -P smbd_anon_write $var_smbd_anon_write
</fix><fix rule="audit_rules_dac_modification_removexattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S removexattr.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_smartd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'smartd.service'
"$SYSTEMCTL_EXEC" disable 'smartd.service'
"$SYSTEMCTL_EXEC" mask 'smartd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^smartd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'smartd.socket'
    "$SYSTEMCTL_EXEC" disable 'smartd.socket'
    "$SYSTEMCTL_EXEC" mask 'smartd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'smartd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_dhcpc_exec_iptables" strategy="enable">
var_dhcpc_exec_iptables="<sub idref="var_dhcpc_exec_iptables" />"

setsebool -P dhcpc_exec_iptables $var_dhcpc_exec_iptables
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_abrt-addon-ccpp_removed" strategy="disable">
# CAUTION: This remediation script will remove abrt-addon-ccpp
#	   from the system, and may remove any packages
#	   that depend on abrt-addon-ccpp. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "abrt-addon-ccpp" ; then
    yum remove -y "abrt-addon-ccpp"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_postfix_local_write_mail_spool" strategy="enable">
var_postfix_local_write_mail_spool="<sub idref="var_postfix_local_write_mail_spool" />"

setsebool -P postfix_local_write_mail_spool $var_postfix_local_write_mail_spool
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mozilla_read_content" strategy="enable">
var_mozilla_read_content="<sub idref="var_mozilla_read_content" />"

setsebool -P mozilla_read_content $var_mozilla_read_content
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_rsync_client" strategy="enable">
var_rsync_client="<sub idref="var_rsync_client" />"

setsebool -P rsync_client $var_rsync_client
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_sandbox_use_mknod" strategy="enable">
var_virt_sandbox_use_mknod="<sub idref="var_virt_sandbox_use_mknod" />"

setsebool -P virt_sandbox_use_mknod $var_virt_sandbox_use_mknod
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_fenced_can_ssh" strategy="enable">
var_fenced_can_ssh="<sub idref="var_fenced_can_ssh" />"

setsebool -P fenced_can_ssh $var_fenced_can_ssh
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_rsyslog_installed" strategy="enable">
if ! rpm -q --quiet "rsyslog" ; then
    yum install -y "rsyslog"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mpd_enable_homedirs" strategy="enable">
var_mpd_enable_homedirs="<sub idref="var_mpd_enable_homedirs" />"

setsebool -P mpd_enable_homedirs $var_mpd_enable_homedirs
</fix><fix rule="audit_rules_login_events">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/var/log/tallylog" "wa" "logins"
fix_audit_watch_rule "augenrules" "/var/log/tallylog" "wa" "logins"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/var/run/faillock" "wa" "logins"
fix_audit_watch_rule "augenrules" "/var/run/faillock" "wa" "logins"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/var/log/lastlog" "wa" "logins"
fix_audit_watch_rule "augenrules" "/var/log/lastlog" "wa" "logins"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_secadm_exec_content" strategy="enable">
var_secadm_exec_content="<sub idref="var_secadm_exec_content" />"

setsebool -P secadm_exec_content $var_secadm_exec_content
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_audit_installed" strategy="enable">
if ! rpm -q --quiet "audit" ; then
    yum install -y "audit"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_disable_root_login" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*PermitRootLogin\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "PermitRootLogin no" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "PermitRootLogin no" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix rule="grub2_pti_argument">

#in later versions of rhel grub2-editenv is used
grub2-editenv - set "$(grub2-editenv - list | grep kernelopts) pti=on"
</fix><fix rule="audit_rules_time_clock_settime">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S clock_settime -F a0=.* \(-F key=\|-k \).*"
	GROUP="clock_settime"
	FULL_RULE="-a always,exit -F arch=$ARCH -S clock_settime -F a0=0x0 -k time-change"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xdm_sysadm_login" strategy="enable">
var_xdm_sysadm_login="<sub idref="var_xdm_sysadm_login" />"

setsebool -P xdm_sysadm_login $var_xdm_sysadm_login
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_ip6tables_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'ip6tables.service'
"$SYSTEMCTL_EXEC" enable 'ip6tables.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_execstack" strategy="enable">
var_selinuxuser_execstack="<sub idref="var_selinuxuser_execstack" />"

setsebool -P selinuxuser_execstack $var_selinuxuser_execstack
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ftpd_full_access" strategy="enable">
var_ftpd_full_access="<sub idref="var_ftpd_full_access" />"

setsebool -P ftpd_full_access $var_ftpd_full_access
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_firewalld_installed" strategy="enable">
if ! rpm -q --quiet "firewalld" ; then
    yum install -y "firewalld"
fi
</fix><fix rule="audit_rules_unsuccessful_file_modification_fchown">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fchown -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fchown -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S fchown -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S fchown -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="accounts_umask_etc_profile">
var_accounts_user_umask="<sub idref="var_accounts_user_umask" />"

grep -q umask /etc/profile &amp;&amp; \
  sed -i "s/umask.*/umask $var_accounts_user_umask/g" /etc/profile
if ! [ $? -eq 0 ]; then
    echo "umask $var_accounts_user_umask" &gt;&gt; /etc/profile
fi
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_default_rp_filter" strategy="disable">
sysctl_net_ipv4_conf_default_rp_filter_value="<sub idref="sysctl_net_ipv4_conf_default_rp_filter_value" />"

#
# Set runtime for net.ipv4.conf.default.rp_filter
#
/sbin/sysctl -q -n -w net.ipv4.conf.default.rp_filter="$sysctl_net_ipv4_conf_default_rp_filter_value"

#
# If net.ipv4.conf.default.rp_filter present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.conf.default.rp_filter = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.default.rp_filter' "$sysctl_net_ipv4_conf_default_rp_filter_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_daemons_dump_core" strategy="enable">
var_daemons_dump_core="<sub idref="var_daemons_dump_core" />"

setsebool -P daemons_dump_core $var_daemons_dump_core
</fix><fix rule="chronyd_or_ntpd_specify_multiple_servers">
var_multiple_time_servers="<sub idref="var_multiple_time_servers" />"

config_file="/etc/ntp.conf"
/usr/sbin/pidof ntpd || config_file="/etc/chrony.conf"

if ! [ "$(grep -c '^server' "$config_file")" -gt 1 ] ; then
  if ! grep -q '#[[:space:]]*server' "$config_file" ; then
    for server in $(echo "$var_multiple_time_servers" | tr ',' '\n') ; do
      printf '\nserver %s iburst' "$server" &gt;&gt; "$config_file"
    done
  else
    sed -i 's/#[ \t]*server/server/g' "$config_file"
  fi
fi
</fix><fix rule="audit_rules_etc_group_open_by_handle_at">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S open_by_handle_at -F a2&amp;03 -F path=/etc/group.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S open_by_handle_at -F a2&amp;03 -F path=/etc/group -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_sshd_config" strategy="configure">
chmod 0600 /etc/ssh/sshd_config
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cron_userdomain_transition" strategy="enable">
var_cron_userdomain_transition="<sub idref="var_cron_userdomain_transition" />"

setsebool -P cron_userdomain_transition $var_cron_userdomain_transition
</fix><fix rule="accounts_password_pam_retry">
var_password_pam_retry="<sub idref="var_password_pam_retry" />"

if grep -q "retry=" /etc/pam.d/system-auth ; then
	sed -i --follow-symlinks "s/\(retry *= *\).*/\1$var_password_pam_retry/" /etc/pam.d/system-auth
else
	sed -i --follow-symlinks "/pam_pwquality.so/ s/$/ retry=$var_password_pam_retry/" /etc/pam.d/system-auth
fi
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv6_conf_all_accept_redirects" strategy="disable">
sysctl_net_ipv6_conf_all_accept_redirects_value="<sub idref="sysctl_net_ipv6_conf_all_accept_redirects_value" />"

#
# Set runtime for net.ipv6.conf.all.accept_redirects
#
/sbin/sysctl -q -n -w net.ipv6.conf.all.accept_redirects="$sysctl_net_ipv6_conf_all_accept_redirects_value"

#
# If net.ipv6.conf.all.accept_redirects present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv6.conf.all.accept_redirects = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv6.conf.all.accept_redirects' "$sysctl_net_ipv6_conf_all_accept_redirects_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_vsftpd_installed" strategy="enable">
if ! rpm -q --quiet "vsftpd" ; then
    yum install -y "vsftpd"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_psacct_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'psacct.service'
"$SYSTEMCTL_EXEC" enable 'psacct.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_gnutls-utils_installed" strategy="enable">
if ! rpm -q --quiet "gnutls-utils" ; then
    yum install -y "gnutls-utils"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_use_sasl" strategy="enable">
var_httpd_use_sasl="<sub idref="var_httpd_use_sasl" />"

setsebool -P httpd_use_sasl $var_httpd_use_sasl
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_cron_weekly" strategy="configure">
chmod 0700 /etc/cron.weekly/
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_use_samba" strategy="enable">
var_virt_use_samba="<sub idref="var_virt_use_samba" />"

setsebool -P virt_use_samba $var_virt_use_samba
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_boinc_execmem" strategy="enable">
var_boinc_execmem="<sub idref="var_boinc_execmem" />"

setsebool -P boinc_execmem $var_boinc_execmem
</fix><fix rule="audit_rules_unsuccessful_file_modification_rename">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S rename -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S rename -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S rename -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S rename -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="sssd_run_as_sssd_user">
found=false
for f in $( ls /etc/sssd/sssd.conf /etc/sssd/conf.d/*.conf 2&gt; /dev/null ) ; do
	user=$( awk '/^\s*\[/{f=0} /^\s*\[sssd\]/{f=1} f{nu=gensub("^\\s*user\\s*=\\s*(\\S+).*","\\1",1); if($0!=nu){user=nu}} END{print user}' $f )
	if [ -n "$user" ] ; then
		if [ "$user" != sssd ] ; then
			sed -i 's/^\s*user\s*=.*/user = sssd/' $f
		fi
		found=true
	fi
done

if ! $found ; then
	SSSD_CONF="/etc/sssd/conf.d/ospp.conf"
	mkdir -p $( dirname $SSSD_CONF )
	touch $SSSD_CONF
	chown root:root $SSSD_CONF
	chmod 600 $SSSD_CONF
	echo -e "[sssd]\nuser = sssd" &gt;&gt; $SSSD_CONF
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_openssh-server_installed" strategy="enable">
if ! rpm -q --quiet "openssh-server" ; then
    yum install -y "openssh-server"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ftpd_anon_write" strategy="enable">
var_ftpd_anon_write="<sub idref="var_ftpd_anon_write" />"

setsebool -P ftpd_anon_write $var_ftpd_anon_write
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ftpd_use_fusefs" strategy="enable">
var_ftpd_use_fusefs="<sub idref="var_ftpd_use_fusefs" />"

setsebool -P ftpd_use_fusefs $var_ftpd_use_fusefs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_logging_syslogd_can_sendmail" strategy="enable">
var_logging_syslogd_can_sendmail="<sub idref="var_logging_syslogd_can_sendmail" />"

setsebool -P logging_syslogd_can_sendmail $var_logging_syslogd_can_sendmail
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_domain_kernel_load_modules" strategy="enable">
var_domain_kernel_load_modules="<sub idref="var_domain_kernel_load_modules" />"

setsebool -P domain_kernel_load_modules $var_domain_kernel_load_modules
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_ssi_exec" strategy="enable">
var_httpd_ssi_exec="<sub idref="var_httpd_ssi_exec" />"

setsebool -P httpd_ssi_exec $var_httpd_ssi_exec
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mcelog_exec_scripts" strategy="enable">
var_mcelog_exec_scripts="<sub idref="var_mcelog_exec_scripts" />"

setsebool -P mcelog_exec_scripts $var_mcelog_exec_scripts
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_user_max_user_namespaces" strategy="disable">

#
# Set runtime for user.max_user_namespaces
#
/sbin/sysctl -q -n -w user.max_user_namespaces="0"

#
# If user.max_user_namespaces present in /etc/sysctl.conf, change value to "0"
#	else, add "user.max_user_namespaces = 0" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^user.max_user_namespaces' "0" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_quota_nld_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'quota_nld.service'
"$SYSTEMCTL_EXEC" disable 'quota_nld.service'
"$SYSTEMCTL_EXEC" mask 'quota_nld.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^quota_nld.socket'; then
    "$SYSTEMCTL_EXEC" stop 'quota_nld.socket'
    "$SYSTEMCTL_EXEC" disable 'quota_nld.socket'
    "$SYSTEMCTL_EXEC" mask 'quota_nld.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'quota_nld.service' || true
</fix><fix rule="dconf_gnome_remote_access_credential_prompt">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/Vino\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/Vino]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "authentication-methods" "['vnc']" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "['vnc']")"
    if grep -q "^\\s*authentication-methods" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*authentication-methods\\s*=\\s*.*/authentication-methods=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/Vino\\]|a\\authentication-methods=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/Vino/authentication-methods$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/Vino/authentication-methods" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_firewalld_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'firewalld.service'
"$SYSTEMCTL_EXEC" enable 'firewalld.service'
</fix><fix reboot="false" rule="mount_option_tmp_nosuid">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /tmp || { echo "Not remediating, because there is no record of /tmp in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/tmp" "nosuid" "" ""

	ensure_partition_is_mounted "/tmp"
}

perform_remediation
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_udf_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install udf" /etc/modprobe.d/udf.conf ; then
	sed -i 's/^install udf.*/install udf /bin/true/g' /etc/modprobe.d/udf.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/udf.conf
	echo "install udf /bin/true" &gt;&gt; /etc/modprobe.d/udf.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_domain_fd_use" strategy="enable">
var_domain_fd_use="<sub idref="var_domain_fd_use" />"

setsebool -P domain_fd_use $var_domain_fd_use
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_openssh-server_removed" strategy="disable">
# CAUTION: This remediation script will remove openssh-server
#	   from the system, and may remove any packages
#	   that depend on openssh-server. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "openssh-server" ; then
    yum remove -y "openssh-server"
fi
</fix><fix rule="dconf_gnome_screensaver_idle_delay">
inactivity_timeout_value="<sub idref="inactivity_timeout_value" />"

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/desktop/session\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/desktop/session]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "idle-delay" "uint32 ${inactivity_timeout_value}" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "uint32 ${inactivity_timeout_value}")"
    if grep -q "^\\s*idle-delay" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*idle-delay\\s*=\\s*.*/idle-delay=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/desktop/session\\]|a\\idle-delay=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/session/idle-delay$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/session/idle-delay" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix rule="audit_rules_unsuccessful_file_modification_open_by_handle_at">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_builtin_scripting" strategy="enable">
var_httpd_builtin_scripting="<sub idref="var_httpd_builtin_scripting" />"

setsebool -P httpd_builtin_scripting $var_httpd_builtin_scripting
</fix><fix rule="audit_rules_dac_modification_setxattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S setxattr.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_talk_removed" strategy="disable">
# CAUTION: This remediation script will remove talk
#	   from the system, and may remove any packages
#	   that depend on talk. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "talk" ; then
    yum remove -y "talk"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ksmtuned_use_cifs" strategy="enable">
var_ksmtuned_use_cifs="<sub idref="var_ksmtuned_use_cifs" />"

setsebool -P ksmtuned_use_cifs $var_ksmtuned_use_cifs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xserver_clients_write_xshm" strategy="enable">
var_xserver_clients_write_xshm="<sub idref="var_xserver_clients_write_xshm" />"

setsebool -P xserver_clients_write_xshm $var_xserver_clients_write_xshm
</fix><fix rule="audit_rules_unsuccessful_file_modification_lchown">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S lchown -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S lchown -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S lchown -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S lchown -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_nfs_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'nfs.service'
"$SYSTEMCTL_EXEC" disable 'nfs.service'
"$SYSTEMCTL_EXEC" mask 'nfs.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^nfs.socket'; then
    "$SYSTEMCTL_EXEC" stop 'nfs.socket'
    "$SYSTEMCTL_EXEC" disable 'nfs.socket'
    "$SYSTEMCTL_EXEC" mask 'nfs.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'nfs.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_openscap-scanner_installed" strategy="enable">
if ! rpm -q --quiet "openscap-scanner" ; then
    yum install -y "openscap-scanner"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_polyinstantiation_enabled" strategy="enable">
var_polyinstantiation_enabled="<sub idref="var_polyinstantiation_enabled" />"

setsebool -P polyinstantiation_enabled $var_polyinstantiation_enabled
</fix><fix rule="auditd_data_disk_error_action">
var_auditd_disk_error_action="<sub idref="var_auditd_disk_error_action" />"

#
# If disk_error_action present in /etc/audit/auditd.conf, change value
# to var_auditd_disk_error_action, else
# add "disk_error_action = $var_auditd_disk_error_action" to /etc/audit/auditd.conf
#

if grep --silent ^disk_error_action /etc/audit/auditd.conf ; then
        sed -i 's/^disk_error_action.*/disk_error_action = '"$var_auditd_disk_error_action"'/g' /etc/audit/auditd.conf
else
        echo -e "\n# Set disk_error_action to $var_auditd_disk_error_action per security requirements" &gt;&gt; /etc/audit/auditd.conf
        echo "disk_error_action = $var_auditd_disk_error_action" &gt;&gt; /etc/audit/auditd.conf
fi
</fix><fix reboot="false" rule="mount_option_dev_shm_nodev">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "no" = 'yes'; then
		assert_mount_point_in_fstab /dev/shm || { echo "Not remediating, because there is no record of /dev/shm in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/dev/shm" "nodev" "tmpfs" "tmpfs"

	ensure_partition_is_mounted "/dev/shm"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_tcp_wrappers_installed" strategy="enable">
if ! rpm -q --quiet "tcp_wrappers" ; then
    yum install -y "tcp_wrappers"
fi
</fix><fix rule="audit_rules_kernel_module_loading_delete">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
# Note: 32-bit and 64-bit kernel syscall numbers not always line up =&gt;
#       it's required on a 64-bit system to check also for the presence
#       of 32-bit's equivalent of the corresponding rule.
#       (See `man 7 audit.rules` for details )
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S delete_module \(-F key=\|-k \).*"
	GROUP="modules"
	FULL_RULE="-a always,exit -F arch=$ARCH -S delete_module -k modules"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="auditd_data_retention_flush">
var_auditd_flush="<sub idref="var_auditd_flush" />"

AUDITCONFIG=/etc/audit/auditd.conf

# if flush is present, flush param edited to var_auditd_flush
# else flush param is defined by var_auditd_flush
#
# the freq param is only used value 'incremental' and will be
# commented out if flush != incremental
#
# if flush == incremental &amp;&amp; freq param is not defined, it 
# will be defined as the package-default value of 20

grep -q ^flush $AUDITCONFIG &amp;&amp; \
  sed -i 's/^flush.*/flush = '"$var_auditd_flush"'/g' $AUDITCONFIG
if ! [ $? -eq 0 ]; then
  echo "flush = $var_auditd_flush" &gt;&gt; $AUDITCONFIG
fi

if ! [ "$var_auditd_flush" == "incremental" ]; then
  sed -i 's/^freq/##freq/g' $AUDITCONFIG
elif [ "$var_auditd_flush" == "incremental" ]; then
  grep -q freq $AUDITCONFIG &amp;&amp; \
    sed -i 's/^#\+freq/freq/g' $AUDITCONFIG
  if ! [ $? -eq 0 ]; then
    echo "freq = 20" &gt;&gt; $AUDITCONFIG
  fi
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mozilla_plugin_use_bluejeans" strategy="enable">
var_mozilla_plugin_use_bluejeans="<sub idref="var_mozilla_plugin_use_bluejeans" />"

setsebool -P mozilla_plugin_use_bluejeans $var_mozilla_plugin_use_bluejeans
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_varnishd_connect_any" strategy="enable">
var_varnishd_connect_any="<sub idref="var_varnishd_connect_any" />"

setsebool -P varnishd_connect_any $var_varnishd_connect_any
</fix><fix rule="dconf_gnome_screensaver_lock_locked">

# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/screensaver/lock-enabled$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/screensaver/lock-enabled" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix rule="audit_rules_execution_semanage">

PATTERN="-a always,exit -F path=/usr/sbin/semanage\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/sbin/semanage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_pcscd_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'pcscd.service'
"$SYSTEMCTL_EXEC" enable 'pcscd.service'
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv6_conf_default_accept_source_route" strategy="disable">
sysctl_net_ipv6_conf_default_accept_source_route_value="<sub idref="sysctl_net_ipv6_conf_default_accept_source_route_value" />"

#
# Set runtime for net.ipv6.conf.default.accept_source_route
#
/sbin/sysctl -q -n -w net.ipv6.conf.default.accept_source_route="$sysctl_net_ipv6_conf_default_accept_source_route_value"

#
# If net.ipv6.conf.default.accept_source_route present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv6.conf.default.accept_source_route = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv6.conf.default.accept_source_route' "$sysctl_net_ipv6_conf_default_accept_source_route_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_read_user_content" strategy="enable">
var_httpd_read_user_content="<sub idref="var_httpd_read_user_content" />"

setsebool -P httpd_read_user_content $var_httpd_read_user_content
</fix><fix rule="banner_etc_issue">
login_banner_text="<sub idref="login_banner_text" />"

# There was a regular-expression matching various banners, needs to be expanded
expanded=$(echo "$login_banner_text" | sed 's/(\\\\\x27)\*/\\\x27/g;s/(\\\x27)\*//g;s/(\^\(.*\)\$|.*$/\1/g;s/\[\\s\\n\][+*]/ /g;s/\\//g;s/[^-]- /\n\n-/g;s/(n)\**//g')
formatted=$(echo "$expanded" | fold -sw 80)

cat &lt;&lt;EOF &gt;/etc/issue
$formatted
EOF

printf "\n" &gt;&gt; /etc/issue
</fix><fix rule="dconf_gnome_remote_access_encryption">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/Vino\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/Vino]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "require-encryption" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*require-encryption" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*require-encryption\\s*=\\s*.*/require-encryption=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/Vino\\]|a\\require-encryption=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/Vino/require-encryption$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/Vino/require-encryption" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix rule="audit_rules_unsuccessful_file_modification_fremovexattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fremovexattr -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fremovexattr -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S fremovexattr -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S fremovexattr -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix reboot="false" rule="mount_option_var_log_nodev">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/log || { echo "Not remediating, because there is no record of /var/log in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/log" "nodev" "" ""

	ensure_partition_is_mounted "/var/log"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_iprutils_removed" strategy="disable">
# CAUTION: This remediation script will remove iprutils
#	   from the system, and may remove any packages
#	   that depend on iprutils. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "iprutils" ; then
    yum remove -y "iprutils"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_iptables_installed" strategy="enable">
if ! rpm -q --quiet "iptables" ; then
    yum install -y "iptables"
fi
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_kernel_kptr_restrict" strategy="disable">

#
# Set runtime for kernel.kptr_restrict
#
/sbin/sysctl -q -n -w kernel.kptr_restrict="1"

#
# If kernel.kptr_restrict present in /etc/sysctl.conf, change value to "1"
#	else, add "kernel.kptr_restrict = 1" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^kernel.kptr_restrict' "1" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mpd_use_nfs" strategy="enable">
var_mpd_use_nfs="<sub idref="var_mpd_use_nfs" />"

setsebool -P mpd_use_nfs $var_mpd_use_nfs
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_sudo_installed" strategy="enable">
if ! rpm -q --quiet "sudo" ; then
    yum install -y "sudo"
fi
</fix><fix rule="aide_periodic_cron_checking">
if ! rpm -q --quiet "aide" ; then
    yum install -y "aide"
fi

if ! grep -q "/usr/sbin/aide --check" /etc/crontab ; then
    echo "05 4 * * * root /usr/sbin/aide --check" &gt;&gt; /etc/crontab
else
    sed -i '/^.*\/usr\/sbin\/aide --check.*$/d' /etc/crontab
    echo "05 4 * * * root /usr/sbin/aide --check" &gt;&gt; /etc/crontab
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_dovecot_removed" strategy="disable">
# CAUTION: This remediation script will remove dovecot
#	   from the system, and may remove any packages
#	   that depend on dovecot. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "dovecot" ; then
    yum remove -y "dovecot"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_polipo_session_bind_all_unreserved_ports" strategy="enable">
var_polipo_session_bind_all_unreserved_ports="<sub idref="var_polipo_session_bind_all_unreserved_ports" />"

setsebool -P polipo_session_bind_all_unreserved_ports $var_polipo_session_bind_all_unreserved_ports
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_samba_share_fusefs" strategy="enable">
var_samba_share_fusefs="<sub idref="var_samba_share_fusefs" />"

setsebool -P samba_share_fusefs $var_samba_share_fusefs
</fix><fix rule="audit_rules_dac_modification_lremovexattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S lremovexattr.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_all_rp_filter" strategy="disable">
sysctl_net_ipv4_conf_all_rp_filter_value="<sub idref="sysctl_net_ipv4_conf_all_rp_filter_value" />"

#
# Set runtime for net.ipv4.conf.all.rp_filter
#
/sbin/sysctl -q -n -w net.ipv4.conf.all.rp_filter="$sysctl_net_ipv4_conf_all_rp_filter_value"

#
# If net.ipv4.conf.all.rp_filter present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.conf.all.rp_filter = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.all.rp_filter' "$sysctl_net_ipv4_conf_all_rp_filter_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_grub2_cfg" strategy="configure">

chgrp 0 /boot/grub2/grub.cfg
</fix><fix rule="accounts_logon_fail_delay">

# Set variables
var_accounts_fail_delay="<sub idref="var_accounts_fail_delay" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/login.defs' '^FAIL_DELAY' "$var_accounts_fail_delay" '@CCENUM@' '%s %s'
</fix><fix rule="securetty_root_login_console_only">sed -i '/^vc\//d' /etc/securetty
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_fs_suid_dumpable" strategy="disable">

#
# Set runtime for fs.suid_dumpable
#
/sbin/sysctl -q -n -w fs.suid_dumpable="0"

#
# If fs.suid_dumpable present in /etc/sysctl.conf, change value to "0"
#	else, add "fs.suid_dumpable = 0" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^fs.suid_dumpable' "0" '@CCENUM@'
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_tcp_syncookies" strategy="disable">
sysctl_net_ipv4_tcp_syncookies_value="<sub idref="sysctl_net_ipv4_tcp_syncookies_value" />"

#
# Set runtime for net.ipv4.tcp_syncookies
#
/sbin/sysctl -q -n -w net.ipv4.tcp_syncookies="$sysctl_net_ipv4_tcp_syncookies_value"

#
# If net.ipv4.tcp_syncookies present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.tcp_syncookies = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.tcp_syncookies' "$sysctl_net_ipv4_tcp_syncookies_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_pppd_for_user" strategy="enable">
var_pppd_for_user="<sub idref="var_pppd_for_user" />"

setsebool -P pppd_for_user $var_pppd_for_user
</fix><fix rule="file_ownership_var_log_audit">
if LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then
  GROUP=$(awk -F "=" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')
  if ! [ "${GROUP}" == 'root' ] ; then
    chown root.${GROUP} /var/log/audit
    chown root.${GROUP} /var/log/audit/audit.log*
  else
    chown root.root /var/log/audit
    chown root.root /var/log/audit/audit.log*
  fi
else
  chown root.root /var/log/audit
  chown root.root /var/log/audit/audit.log*
fi
</fix><fix rule="audit_rules_file_deletion_events_unlinkat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S unlinkat.*"
	GROUP="delete"
	FULL_RULE="-a always,exit -F arch=$ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_cgred_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'cgred.service'
"$SYSTEMCTL_EXEC" disable 'cgred.service'
"$SYSTEMCTL_EXEC" mask 'cgred.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^cgred.socket'; then
    "$SYSTEMCTL_EXEC" stop 'cgred.socket'
    "$SYSTEMCTL_EXEC" disable 'cgred.socket'
    "$SYSTEMCTL_EXEC" mask 'cgred.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'cgred.service' || true
</fix><fix rule="audit_rules_privileged_commands_usernetctl">

PATTERN="-a always,exit -F path=/usr/sbin/usernetctl\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/sbin/usernetctl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="audit_rules_execution_setsebool">

PATTERN="-a always,exit -F path=/usr/sbin/setsebool\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/sbin/setsebool -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_sshd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'sshd.service'
"$SYSTEMCTL_EXEC" disable 'sshd.service'
"$SYSTEMCTL_EXEC" mask 'sshd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^sshd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'sshd.socket'
    "$SYSTEMCTL_EXEC" disable 'sshd.socket'
    "$SYSTEMCTL_EXEC" mask 'sshd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'sshd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_sendmail_removed" strategy="disable">
# CAUTION: This remediation script will remove sendmail
#	   from the system, and may remove any packages
#	   that depend on sendmail. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "sendmail" ; then
    yum remove -y "sendmail"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xend_run_blktap" strategy="enable">
var_xend_run_blktap="<sub idref="var_xend_run_blktap" />"

setsebool -P xend_run_blktap $var_xend_run_blktap
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_do_not_permit_user_env" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*PermitUserEnvironment\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "PermitUserEnvironment yes" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "PermitUserEnvironment yes" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix rule="audit_rules_time_stime">
<sub idref="function_perform_audit_adjtimex_settimeofday_stime_remediation" />
perform_audit_adjtimex_settimeofday_stime_remediation
</fix><fix rule="chronyd_or_ntpd_set_maxpoll">
var_time_service_set_maxpoll="<sub idref="var_time_service_set_maxpoll" />"


config_file="/etc/ntp.conf"
/usr/sbin/pidof ntpd || config_file="/etc/chrony.conf"


# Set maxpoll values to var_time_service_set_maxpoll
sed -i "s/^\(server.*maxpoll\) [0-9][0-9]*\(.*\)$/\1 $var_time_service_set_maxpoll \2/" "$config_file"

# Add maxpoll to server entries without maxpoll
grep "^server" "$config_file" | grep -v maxpoll | while read -r line ; do
        sed -i "s/$line/&amp; maxpoll $var_time_service_set_maxpoll/" "$config_file"
done
</fix><fix rule="network_ipv6_disable_rpc">
# Drop 'tcp6' and 'udp6' entries from /etc/netconfig to prevent RPC
# services for NFSv4 from attempting to start IPv6 network listeners
declare -a IPV6_RPC_ENTRIES=("tcp6" "udp6")

for rpc_entry in "${IPV6_RPC_ENTRIES[@]}"
do
	sed -i "/^${rpc_entry}[[:space:]]\\+tpi\\_.*inet6.*/d" /etc/netconfig
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_logging_syslogd_run_nagios_plugins" strategy="enable">
var_logging_syslogd_run_nagios_plugins="<sub idref="var_logging_syslogd_run_nagios_plugins" />"

setsebool -P logging_syslogd_run_nagios_plugins $var_logging_syslogd_run_nagios_plugins
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rpcgssd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rpcgssd.service'
"$SYSTEMCTL_EXEC" disable 'rpcgssd.service'
"$SYSTEMCTL_EXEC" mask 'rpcgssd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rpcgssd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rpcgssd.socket'
    "$SYSTEMCTL_EXEC" disable 'rpcgssd.socket'
    "$SYSTEMCTL_EXEC" mask 'rpcgssd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rpcgssd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="disable_host_auth" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*HostbasedAuthentication\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "HostbasedAuthentication no" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "HostbasedAuthentication no" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix rule="audit_rules_privileged_commands_newgrp">

PATTERN="-a always,exit -F path=/usr/bin/newgrp\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="audit_rules_unsuccessful_file_modification_open_by_handle_at_o_creat">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cobbler_can_network_connect" strategy="enable">
var_cobbler_can_network_connect="<sub idref="var_cobbler_can_network_connect" />"

setsebool -P cobbler_can_network_connect $var_cobbler_can_network_connect
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_sandbox_use_sys_admin" strategy="enable">
var_virt_sandbox_use_sys_admin="<sub idref="var_virt_sandbox_use_sys_admin" />"

setsebool -P virt_sandbox_use_sys_admin $var_virt_sandbox_use_sys_admin
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_tftp_home_dir" strategy="enable">
var_tftp_home_dir="<sub idref="var_tftp_home_dir" />"

setsebool -P tftp_home_dir $var_tftp_home_dir
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_tor_bind_all_unreserved_ports" strategy="enable">
var_tor_bind_all_unreserved_ports="<sub idref="var_tor_bind_all_unreserved_ports" />"

setsebool -P tor_bind_all_unreserved_ports $var_tor_bind_all_unreserved_ports
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_git_cgi_use_cifs" strategy="enable">
var_git_cgi_use_cifs="<sub idref="var_git_cgi_use_cifs" />"

setsebool -P git_cgi_use_cifs $var_git_cgi_use_cifs
</fix><fix rule="audit_rules_unsuccessful_file_modification_open_o_creat">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_privoxy_connect_any" strategy="enable">
var_privoxy_connect_any="<sub idref="var_privoxy_connect_any" />"

setsebool -P privoxy_connect_any $var_privoxy_connect_any
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_can_network_relay" strategy="enable">
var_httpd_can_network_relay="<sub idref="var_httpd_can_network_relay" />"

setsebool -P httpd_can_network_relay $var_httpd_can_network_relay
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cobbler_anon_write" strategy="enable">
var_cobbler_anon_write="<sub idref="var_cobbler_anon_write" />"

setsebool -P cobbler_anon_write $var_cobbler_anon_write
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_pcsc-lite_installed" strategy="enable">
if ! rpm -q --quiet "pcsc-lite" ; then
    yum install -y "pcsc-lite"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_etc_passwd" strategy="configure">

chgrp 0 /etc/passwd
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_disable_user_known_hosts" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*IgnoreUserKnownHosts\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "IgnoreUserKnownHosts yes" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "IgnoreUserKnownHosts yes" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_sanlock_use_samba" strategy="enable">
var_sanlock_use_samba="<sub idref="var_sanlock_use_samba" />"

setsebool -P sanlock_use_samba $var_sanlock_use_samba
</fix><fix rule="audit_rules_unsuccessful_file_modification_removexattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S removexattr -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S removexattr -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S removexattr -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S removexattr -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_postfix_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'postfix.service'
"$SYSTEMCTL_EXEC" enable 'postfix.service'
</fix><fix rule="chronyd_no_chronyc_network">
<sub idref="function_replace_or_append" />
replace_or_append /etc/chrony.conf '^cmdport' 0 '@CCENUM@' '%s %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_cron_daily" strategy="configure">

chgrp 0 /etc/cron.daily/
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_oddjobd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'oddjobd.service'
"$SYSTEMCTL_EXEC" disable 'oddjobd.service'
"$SYSTEMCTL_EXEC" mask 'oddjobd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^oddjobd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'oddjobd.socket'
    "$SYSTEMCTL_EXEC" disable 'oddjobd.socket'
    "$SYSTEMCTL_EXEC" mask 'oddjobd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'oddjobd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_zarafa_setrlimit" strategy="enable">
var_zarafa_setrlimit="<sub idref="var_zarafa_setrlimit" />"

setsebool -P zarafa_setrlimit $var_zarafa_setrlimit
</fix><fix rule="audit_rules_privileged_commands_userhelper">

PATTERN="-a always,exit -F path=/usr/sbin/userhelper\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/sbin/userhelper -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ftpd_use_passive_mode" strategy="enable">
var_ftpd_use_passive_mode="<sub idref="var_ftpd_use_passive_mode" />"

setsebool -P ftpd_use_passive_mode $var_ftpd_use_passive_mode
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_samba_create_home_dirs" strategy="enable">
var_samba_create_home_dirs="<sub idref="var_samba_create_home_dirs" />"

setsebool -P samba_create_home_dirs $var_samba_create_home_dirs
</fix><fix rule="dnf-automatic_security_updates_only">
CONF="/etc/dnf/automatic.conf"
APPLY_UPDATES_REGEX="[[:space:]]*\[commands]([^\n\[]*\n+)+?[[:space:]]*upgrade_type"
COMMANDS_REGEX="[[:space:]]*\[commands]"

# Try find [commands] and upgrade_type in automatic.conf, if it exists, set
# it to security, if it isn't here, add it, if [commands] doesn't exist,
# add it there
if grep -qzosP $APPLY_UPDATES_REGEX $CONF; then
    sed -i "s/upgrade_type[^(\n)]*/upgrade_type = security/" $CONF
elif grep -qs $COMMANDS_REGEX $CONF; then
    sed -i "/$COMMANDS_REGEX/a upgrade_type = security" $CONF
else
    mkdir -p /etc/dnf
    echo -e "[commands]\nupgrade_type = security" &gt;&gt; $CONF
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_samba_enable_home_dirs" strategy="enable">
var_samba_enable_home_dirs="<sub idref="var_samba_enable_home_dirs" />"

setsebool -P samba_enable_home_dirs $var_samba_enable_home_dirs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_container_connect_any" strategy="enable">
var_container_connect_any="<sub idref="var_container_connect_any" />"

setsebool -P container_connect_any $var_container_connect_any
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_telnet_removed" strategy="disable">
# CAUTION: This remediation script will remove telnet
#	   from the system, and may remove any packages
#	   that depend on telnet. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "telnet" ; then
    yum remove -y "telnet"
fi
</fix><fix rule="sssd_ldap_start_tls">

AUTHCONFIG="/etc/sysconfig/authconfig"
USELDAPAUTH_REGEX="^USELDAPAUTH="
SSSD_CONF="/etc/sssd/sssd.conf"
LDAP_REGEX='[[:space:]]*\[domain\/[^]]*]([^(\n)]*(\n)+)+?[[:space:]]*ldap_id_use_start_tls'
DOMAIN_REGEX="[[:space:]]*\[domain\/[^]]*]"

# Try find USELDAPAUTH in authconfig. If its here set to 'yes', otherwise append USELDAPAUTH=yes
grep -qs "^USELDAPAUTH=" "$AUTHCONFIG" &amp;&amp; sed -i 's/^USELDAPAUTH=.*/USELDAPAUTH=yes/g' $AUTHCONFIG
if ! [ $? -eq 0 ]; then
        echo "USELDAPAUTH=yes" &gt;&gt; $AUTHCONFIG
fi

# Try find [domain/..] and ldap_id_use_start_tls in sssd.conf, if it exists, set to 'True'
# if ldap_id_use_start_tls isn't here, add it
# if [domain/..] doesn't exist, add it here for default domain
if grep -qzosP $LDAP_REGEX $SSSD_CONF; then
        sed -i 's/ldap_id_use_start_tls[^(\n)]*/ldap_id_use_start_tls = True/' $SSSD_CONF
elif grep -qs $DOMAIN_REGEX $SSSD_CONF; then
        sed -i "/$DOMAIN_REGEX/a ldap_id_use_start_tls = True" $SSSD_CONF
else
        mkdir -p /etc/sssd
        touch $SSSD_CONF
        echo -e "[domain/default]\nldap_id_use_start_tls = True" &gt;&gt; $SSSD_CONF
fi
</fix><fix rule="audit_rules_privileged_commands">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_perform_audit_rules_privileged_commands_remediation" />
perform_audit_rules_privileged_commands_remediation "auditctl" "1000"
perform_audit_rules_privileged_commands_remediation "augenrules" "1000"
</fix><fix rule="audit_rules_mac_modification">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/selinux/" "wa" "MAC-policy"
fix_audit_watch_rule "augenrules" "/etc/selinux/" "wa" "MAC-policy"
</fix><fix rule="dconf_gnome_screensaver_idle_activation_enabled">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/desktop/screensaver\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/desktop/screensaver]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "idle-activation-enabled" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*idle-activation-enabled" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*idle-activation-enabled\\s*=\\s*.*/idle-activation-enabled=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/desktop/screensaver\\]|a\\idle-activation-enabled=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/screensaver/idle-activation-enabled$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/screensaver/idle-activation-enabled" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xguest_use_bluetooth" strategy="enable">
var_xguest_use_bluetooth="<sub idref="var_xguest_use_bluetooth" />"

setsebool -P xguest_use_bluetooth $var_xguest_use_bluetooth
</fix><fix rule="accounts_no_uid_except_zero">awk -F: '$3 == 0 &amp;&amp; $1 != "root" { print $1 }' /etc/passwd | xargs passwd -l
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xserver_object_manager" strategy="enable">
var_xserver_object_manager="<sub idref="var_xserver_object_manager" />"

setsebool -P xserver_object_manager $var_xserver_object_manager
</fix><fix rule="accounts_umask_etc_login_defs">
var_accounts_user_umask="<sub idref="var_accounts_user_umask" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/login.defs' '^UMASK' "$var_accounts_user_umask" '@CCENUM@' '%s %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_zebra_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'zebra.service'
"$SYSTEMCTL_EXEC" disable 'zebra.service'
"$SYSTEMCTL_EXEC" mask 'zebra.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^zebra.socket'; then
    "$SYSTEMCTL_EXEC" stop 'zebra.socket'
    "$SYSTEMCTL_EXEC" disable 'zebra.socket'
    "$SYSTEMCTL_EXEC" mask 'zebra.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'zebra.service' || true
</fix><fix rule="aide_verify_ext_attributes">
if ! rpm -q --quiet "aide" ; then
    yum install -y "aide"
fi

aide_conf="/etc/aide.conf"

groups=$(LC_ALL=C grep "^[A-Z]\+" $aide_conf | grep -v "^ALLXTRAHASHES" | cut -f1 -d '=' | tr -d ' ' | sort -u)

for group in $groups
do
	config=$(grep "^$group\s*=" $aide_conf | cut -f2 -d '=' | tr -d ' ')

	if ! [[ $config = *xattrs* ]]
	then
		if [[ -z $config ]]
		then
			config="xattrs"
		else
			config=$config"+xattrs"
		fi
	fi
	sed -i "s/^$group\s*=.*/$group = $config/g" $aide_conf
done
</fix><fix rule="audit_rules_etc_shadow_open_by_handle_at">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S open_by_handle_at -F a2&amp;03 -F path=/etc/shadow.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix reboot="false" rule="mount_option_home_nodev">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /home || { echo "Not remediating, because there is no record of /home in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/home" "nodev" "" ""

	ensure_partition_is_mounted "/home"
}

perform_remediation
</fix><fix rule="restrict_serial_port_logins">sed -i '/ttyS/d' /etc/securetty
</fix><fix rule="dconf_gnome_disable_ctrlaltdel_reboot">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/settings-daemon/plugins/media-keys\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/settings-daemon/plugins/media-keys]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "logout" "string ''" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "string ''")"
    if grep -q "^\\s*logout" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*logout\\s*=\\s*.*/logout=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/settings-daemon/plugins/media-keys\\]|a\\logout=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/settings-daemon/plugins/media-keys/logout$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/settings-daemon/plugins/media-keys/logout" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_piranha_lvs_can_network_connect" strategy="enable">
var_piranha_lvs_can_network_connect="<sub idref="var_piranha_lvs_can_network_connect" />"

setsebool -P piranha_lvs_can_network_connect $var_piranha_lvs_can_network_connect
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_tmp_exec" strategy="enable">
var_httpd_tmp_exec="<sub idref="var_httpd_tmp_exec" />"

setsebool -P httpd_tmp_exec $var_httpd_tmp_exec
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cdrecord_read_content" strategy="enable">
var_cdrecord_read_content="<sub idref="var_cdrecord_read_content" />"

setsebool -P cdrecord_read_content $var_cdrecord_read_content
</fix><fix rule="audit_rules_unsuccessful_file_modification_truncate">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix reboot="false" rule="mount_option_var_tmp_nosuid">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/tmp || { echo "Not remediating, because there is no record of /var/tmp in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/tmp" "nosuid" "" ""

	ensure_partition_is_mounted "/var/tmp"
}

perform_remediation
</fix><fix rule="enable_fips_mode">
fips-mode-setup --enable
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_cpupower_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'cpupower.service'
"$SYSTEMCTL_EXEC" disable 'cpupower.service'
"$SYSTEMCTL_EXEC" mask 'cpupower.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^cpupower.socket'; then
    "$SYSTEMCTL_EXEC" stop 'cpupower.socket'
    "$SYSTEMCTL_EXEC" disable 'cpupower.socket'
    "$SYSTEMCTL_EXEC" mask 'cpupower.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'cpupower.service' || true
</fix><fix rule="audit_rules_dac_modification_chown">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S chown.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_zebra_write_config" strategy="enable">
var_zebra_write_config="<sub idref="var_zebra_write_config" />"

setsebool -P zebra_write_config $var_zebra_write_config
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_mdmonitor_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'mdmonitor.service'
"$SYSTEMCTL_EXEC" disable 'mdmonitor.service'
"$SYSTEMCTL_EXEC" mask 'mdmonitor.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^mdmonitor.socket'; then
    "$SYSTEMCTL_EXEC" stop 'mdmonitor.socket'
    "$SYSTEMCTL_EXEC" disable 'mdmonitor.socket'
    "$SYSTEMCTL_EXEC" mask 'mdmonitor.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'mdmonitor.service' || true
</fix><fix rule="audit_rules_unsuccessful_file_modification_open_by_handle_at_rule_order">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_etc_passwd" strategy="configure">

chown 0 /etc/passwd
</fix><fix complexity="low" disruption="medium" reboot="false" rule="sssd_offline_cred_expiration" strategy="configure">
SSSD_CONF="/etc/sssd/sssd.conf"
SSSD_OPT="offline_credentials_expiration"
SSSD_OPT_VAL=1
PAM_REGEX="[[:space:]]*\[pam]"
PAM_OPT_REGEX="${PAM_REGEX}([^\n\[]*\n+)+?[[:space:]]*${SSSD_OPT}"

# Try find [pam] and offline_credentials_expiration in sssd.conf, if it exists
# set it to 1, if it doesn't exist add it, if [pam] section doesn't exist add
# the section and the configuration option.
if grep -qzosP $PAM_OPT_REGEX $SSSD_CONF; then
	sed -i "s/${SSSD_OPT}[^(\n)]*/${SSSD_OPT} = ${SSSD_OPT_VAL}/" $SSSD_CONF
elif grep -qs $PAM_REGEX $SSSD_CONF; then
	sed -i "/$PAM_REGEX/a ${SSSD_OPT} = ${SSSD_OPT_VAL}" $SSSD_CONF
else
	mkdir -p /etc/sssd
	touch $SSSD_CONF
	echo -e "[pam]\n${SSSD_OPT} = ${SSSD_OPT_VAL}" &gt;&gt; $SSSD_CONF
fi
</fix><fix rule="dconf_gnome_screensaver_lock_enabled">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/desktop/screensaver\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/desktop/screensaver]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "lock-enabled" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*lock-enabled" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*lock-enabled\\s*=\\s*.*/lock-enabled=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/desktop/screensaver\\]|a\\lock-enabled=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/screensaver/lock-enabled$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/screensaver/lock-enabled" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_pcp_read_generic_logs" strategy="enable">
var_pcp_read_generic_logs="<sub idref="var_pcp_read_generic_logs" />"

setsebool -P pcp_read_generic_logs $var_pcp_read_generic_logs
</fix><fix rule="audit_rules_privileged_commands_newgidmap">

PATTERN="-a always,exit -F path=/usr/bin/newgidmap\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/newgidmap -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="audit_rules_etc_passwd_open">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S open -F a1&amp;03 -F path=/etc/passwd.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S open -F a1&amp;03 -F path=/etc/passwd -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="ensure_gpgcheck_never_disabled">sed -i 's/gpgcheck\s*=.*/gpgcheck=1/g' /etc/yum.repos.d/*
</fix><fix rule="audit_rules_etc_gshadow_open">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S open -F a1&amp;03 -F path=/etc/gshadow.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S open -F a1&amp;03 -F path=/etc/gshadow -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_dnf-automatic_installed" strategy="enable">
if ! rpm -q --quiet "dnf-automatic" ; then
    yum install -y "dnf-automatic"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_httpd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'httpd.service'
"$SYSTEMCTL_EXEC" disable 'httpd.service'
"$SYSTEMCTL_EXEC" mask 'httpd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^httpd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'httpd.socket'
    "$SYSTEMCTL_EXEC" disable 'httpd.socket'
    "$SYSTEMCTL_EXEC" mask 'httpd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'httpd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_squid_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'squid.service'
"$SYSTEMCTL_EXEC" disable 'squid.service'
"$SYSTEMCTL_EXEC" mask 'squid.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^squid.socket'; then
    "$SYSTEMCTL_EXEC" stop 'squid.socket'
    "$SYSTEMCTL_EXEC" disable 'squid.socket'
    "$SYSTEMCTL_EXEC" mask 'squid.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'squid.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_fips_mode" strategy="enable">
var_fips_mode="<sub idref="var_fips_mode" />"

setsebool -P fips_mode $var_fips_mode
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_nagios_run_pnp4nagios" strategy="enable">
var_nagios_run_pnp4nagios="<sub idref="var_nagios_run_pnp4nagios" />"

setsebool -P nagios_run_pnp4nagios $var_nagios_run_pnp4nagios
</fix><fix rule="dconf_gnome_screensaver_user_locks">

# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/screensaver/lock-delay$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/screensaver/lock-delay" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_global_ssp" strategy="enable">
var_global_ssp="<sub idref="var_global_ssp" />"

setsebool -P global_ssp $var_global_ssp
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_libcap-ng-utils_installed" strategy="enable">
if ! rpm -q --quiet "libcap-ng-utils" ; then
    yum install -y "libcap-ng-utils"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_abrt-plugin-rhtsupport_removed" strategy="disable">
# CAUTION: This remediation script will remove abrt-plugin-rhtsupport
#	   from the system, and may remove any packages
#	   that depend on abrt-plugin-rhtsupport. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "abrt-plugin-rhtsupport" ; then
    yum remove -y "abrt-plugin-rhtsupport"
fi
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_kernel_kexec_load_disabled" strategy="disable">

#
# Set runtime for kernel.kexec_load_disabled
#
/sbin/sysctl -q -n -w kernel.kexec_load_disabled="1"

#
# If kernel.kexec_load_disabled present in /etc/sysctl.conf, change value to "1"
#	else, add "kernel.kexec_load_disabled = 1" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^kernel.kexec_load_disabled' "1" '@CCENUM@'
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_kernel_dmesg_restrict" strategy="disable">

#
# Set runtime for kernel.dmesg_restrict
#
/sbin/sysctl -q -n -w kernel.dmesg_restrict="1"

#
# If kernel.dmesg_restrict present in /etc/sysctl.conf, change value to "1"
#	else, add "kernel.dmesg_restrict = 1" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^kernel.dmesg_restrict' "1" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mcelog_client" strategy="enable">
var_mcelog_client="<sub idref="var_mcelog_client" />"

setsebool -P mcelog_client $var_mcelog_client
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_efi_grub2_cfg" strategy="configure">

chown 0 /boot/efi/EFI/redhat/grub.cfg
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_acpid_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'acpid.service'
"$SYSTEMCTL_EXEC" disable 'acpid.service'
"$SYSTEMCTL_EXEC" mask 'acpid.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^acpid.socket'; then
    "$SYSTEMCTL_EXEC" stop 'acpid.socket'
    "$SYSTEMCTL_EXEC" disable 'acpid.socket'
    "$SYSTEMCTL_EXEC" mask 'acpid.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'acpid.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_samba_export_all_ro" strategy="enable">
var_samba_export_all_ro="<sub idref="var_samba_export_all_ro" />"

setsebool -P samba_export_all_ro $var_samba_export_all_ro
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_crond_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'crond.service'
"$SYSTEMCTL_EXEC" enable 'crond.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_netconsole_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'netconsole.service'
"$SYSTEMCTL_EXEC" disable 'netconsole.service'
"$SYSTEMCTL_EXEC" mask 'netconsole.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^netconsole.socket'; then
    "$SYSTEMCTL_EXEC" stop 'netconsole.socket'
    "$SYSTEMCTL_EXEC" disable 'netconsole.socket'
    "$SYSTEMCTL_EXEC" mask 'netconsole.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'netconsole.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_rsyslog-gnutls_installed" strategy="enable">
if ! rpm -q --quiet "rsyslog-gnutls" ; then
    yum install -y "rsyslog-gnutls"
fi
</fix><fix rule="audit_rules_networkconfig_modification">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S .* -k *"
	# Use escaped BRE regex to specify rule group
	GROUP="set\(host\|domain\)name"
	FULL_RULE="-a always,exit -F arch=$ARCH -S sethostname -S setdomainname -k audit_rules_networkconfig_modification"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

# Then perform the remediations for the watch rules
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/issue" "wa" "audit_rules_networkconfig_modification"
fix_audit_watch_rule "augenrules" "/etc/issue" "wa" "audit_rules_networkconfig_modification"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/issue.net" "wa" "audit_rules_networkconfig_modification"
fix_audit_watch_rule "augenrules" "/etc/issue.net" "wa" "audit_rules_networkconfig_modification"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/hosts" "wa" "audit_rules_networkconfig_modification"
fix_audit_watch_rule "augenrules" "/etc/hosts" "wa" "audit_rules_networkconfig_modification"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/sysconfig/network" "wa" "audit_rules_networkconfig_modification"
fix_audit_watch_rule "augenrules" "/etc/sysconfig/network" "wa" "audit_rules_networkconfig_modification"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_serve_cobbler_files" strategy="enable">
var_httpd_serve_cobbler_files="<sub idref="var_httpd_serve_cobbler_files" />"

setsebool -P httpd_serve_cobbler_files $var_httpd_serve_cobbler_files
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_default_secure_redirects" strategy="disable">
sysctl_net_ipv4_conf_default_secure_redirects_value="<sub idref="sysctl_net_ipv4_conf_default_secure_redirects_value" />"

#
# Set runtime for net.ipv4.conf.default.secure_redirects
#
/sbin/sysctl -q -n -w net.ipv4.conf.default.secure_redirects="$sysctl_net_ipv4_conf_default_secure_redirects_value"

#
# If net.ipv4.conf.default.secure_redirects present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.conf.default.secure_redirects = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.default.secure_redirects' "$sysctl_net_ipv4_conf_default_secure_redirects_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_cron_monthly" strategy="configure">
chmod 0700 /etc/cron.monthly/
</fix><fix rule="network_ipv6_privacy_extensions">
# enable randomness in ipv6 address generation
for interface in /etc/sysconfig/network-scripts/ifcfg-*
do
    echo "IPV6_PRIVACY=rfc3041" &gt;&gt; $interface
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_sandbox_use_all_caps" strategy="enable">
var_virt_sandbox_use_all_caps="<sub idref="var_virt_sandbox_use_all_caps" />"

setsebool -P virt_sandbox_use_all_caps $var_virt_sandbox_use_all_caps
</fix><fix rule="grub2_page_poison_argument">

#in later versions of rhel grub2-editenv is used
grub2-editenv - set "$(grub2-editenv - list | grep kernelopts) page_poison=1"
</fix><fix complexity="low" disruption="low" reboot="false" rule="accounts_password_pam_ucredit" strategy="restrict">
var_password_pam_ucredit="<sub idref="var_password_pam_ucredit" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/security/pwquality.conf' '^ucredit' $var_password_pam_ucredit '@CCENUM@' '%s = %s'
</fix><fix rule="aide_scan_notification">
if ! rpm -q --quiet "aide" ; then
    yum install -y "aide"
fi

CRONTAB=/etc/crontab
CRONDIRS='/etc/cron.d /etc/cron.daily /etc/cron.weekly /etc/cron.monthly'

if [ -f /var/spool/cron/root ]; then
	VARSPOOL=/var/spool/cron/root
fi

if ! grep -qR '^.*\/usr\/sbin\/aide\s*\-\-check.*|.*\/bin\/mail\s*-s\s*".*"\s*root@.*$' $CRONTAB $VARSPOOL $CRONDIRS; then
	echo '0 5 * * * root /usr/sbin/aide  --check | /bin/mail -s "$(hostname) - AIDE Integrity Check" root@localhost' &gt;&gt; $CRONTAB
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_use_rawip" strategy="enable">
var_virt_use_rawip="<sub idref="var_virt_use_rawip" />"

setsebool -P virt_use_rawip $var_virt_use_rawip
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_rds_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install rds" /etc/modprobe.d/rds.conf ; then
	sed -i 's/^install rds.*/install rds /bin/true/g' /etc/modprobe.d/rds.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/rds.conf
	echo "install rds /bin/true" &gt;&gt; /etc/modprobe.d/rds.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_tmux_installed" strategy="enable">
if ! rpm -q --quiet "tmux" ; then
    yum install -y "tmux"
fi
</fix><fix reboot="false" rule="mount_option_nosuid_removable_partitions">
var_removable_partition="<sub idref="var_removable_partition" />"
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab "$var_removable_partition" || { echo "Not remediating, because there is no record of $var_removable_partition in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "$var_removable_partition" "nosuid" "" ""

	ensure_partition_is_mounted "$var_removable_partition"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_opensc_installed" strategy="enable">
if ! rpm -q --quiet "opensc" ; then
    yum install -y "opensc"
fi
</fix><fix rule="audit_rules_usergroup_modification">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/group" "wa" "audit_rules_usergroup_modification"
fix_audit_watch_rule "augenrules" "/etc/group" "wa" "audit_rules_usergroup_modification"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/passwd" "wa" "audit_rules_usergroup_modification"
fix_audit_watch_rule "augenrules" "/etc/passwd" "wa" "audit_rules_usergroup_modification"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/gshadow" "wa" "audit_rules_usergroup_modification"
fix_audit_watch_rule "augenrules" "/etc/gshadow" "wa" "audit_rules_usergroup_modification"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/shadow" "wa" "audit_rules_usergroup_modification"
fix_audit_watch_rule "augenrules" "/etc/shadow" "wa" "audit_rules_usergroup_modification"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/security/opasswd" "wa" "audit_rules_usergroup_modification"
fix_audit_watch_rule "augenrules" "/etc/security/opasswd" "wa" "audit_rules_usergroup_modification"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_use_cifs" strategy="enable">
var_httpd_use_cifs="<sub idref="var_httpd_use_cifs" />"

setsebool -P httpd_use_cifs $var_httpd_use_cifs
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_binutils_installed" strategy="enable">
if ! rpm -q --quiet "binutils" ; then
    yum install -y "binutils"
fi
</fix><fix rule="require_smb_client_signing">######################################################################
#By Luke "Brisk-OH" Brisk
#luke.brisk@boeing.com or luke.brisk@gmail.com
######################################################################

CLIENTSIGNING=$( grep -ic 'client signing' /etc/samba/smb.conf )

if [ "$CLIENTSIGNING" -eq 0 ];  then
	# Add to global section
	sed -i 's/\[global\]/\[global\]\n\n\tclient signing = mandatory/g' /etc/samba/smb.conf
else
	sed -i 's/[[:blank:]]*client[[:blank:]]signing[[:blank:]]*=[[:blank:]]*no/        client signing = mandatory/g' /etc/samba/smb.conf
fi
</fix><fix rule="audit_rules_usergroup_modification_opasswd">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/security/opasswd" "wa" "audit_rules_usergroup_modification"
fix_audit_watch_rule "augenrules" "/etc/security/opasswd" "wa" "audit_rules_usergroup_modification"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_secure_mode_policyload" strategy="enable">
var_secure_mode_policyload="<sub idref="var_secure_mode_policyload" />"

setsebool -P secure_mode_policyload $var_secure_mode_policyload
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_icmp_echo_ignore_broadcasts" strategy="disable">
sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value="<sub idref="sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value" />"

#
# Set runtime for net.ipv4.icmp_echo_ignore_broadcasts
#
/sbin/sysctl -q -n -w net.ipv4.icmp_echo_ignore_broadcasts="$sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value"

#
# If net.ipv4.icmp_echo_ignore_broadcasts present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.icmp_echo_ignore_broadcasts = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.icmp_echo_ignore_broadcasts' "$sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_dhcpd_use_ldap" strategy="enable">
var_dhcpd_use_ldap="<sub idref="var_dhcpd_use_ldap" />"

setsebool -P dhcpd_use_ldap $var_dhcpd_use_ldap
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_cockpit_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'cockpit.service'
"$SYSTEMCTL_EXEC" disable 'cockpit.service'
"$SYSTEMCTL_EXEC" mask 'cockpit.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^cockpit.socket'; then
    "$SYSTEMCTL_EXEC" stop 'cockpit.socket'
    "$SYSTEMCTL_EXEC" disable 'cockpit.socket'
    "$SYSTEMCTL_EXEC" mask 'cockpit.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'cockpit.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_portreserve_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'portreserve.service'
"$SYSTEMCTL_EXEC" disable 'portreserve.service'
"$SYSTEMCTL_EXEC" mask 'portreserve.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^portreserve.socket'; then
    "$SYSTEMCTL_EXEC" stop 'portreserve.socket'
    "$SYSTEMCTL_EXEC" disable 'portreserve.socket'
    "$SYSTEMCTL_EXEC" mask 'portreserve.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'portreserve.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="accounts_password_pam_difok" strategy="restrict">
var_password_pam_difok="<sub idref="var_password_pam_difok" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/security/pwquality.conf' '^difok' $var_password_pam_difok '@CCENUM@' '%s = %s'
</fix><fix rule="file_permissions_var_log_audit">
if LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then
  GROUP=$(awk -F "=" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')
  if ! [ "${GROUP}" == 'root' ] ; then
    chmod 0640 /var/log/audit/audit.log
    chmod 0440 /var/log/audit/audit.log.*
  else
    chmod 0600 /var/log/audit/audit.log
    chmod 0400 /var/log/audit/audit.log.*
  fi

  chmod 0640 /etc/audit/audit*
  chmod 0640 /etc/audit/rules.d/*
else
  chmod 0600 /var/log/audit/audit.log
  chmod 0400 /var/log/audit/audit.log.*
  chmod 0640 /etc/audit/audit*
  chmod 0640 /etc/audit/rules.d/*
fi
</fix><fix rule="disable_ctrlaltdel_burstaction">
<sub idref="function_replace_or_append" />
replace_or_append '/etc/systemd/system.conf' '^CtrlAltDelBurstAction=' 'none' '@CCENUM@' '%s=%s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_use_xserver" strategy="enable">
var_virt_use_xserver="<sub idref="var_virt_use_xserver" />"

setsebool -P virt_use_xserver $var_virt_use_xserver
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mozilla_plugin_can_network_connect" strategy="enable">
var_mozilla_plugin_can_network_connect="<sub idref="var_mozilla_plugin_can_network_connect" />"

setsebool -P mozilla_plugin_can_network_connect $var_mozilla_plugin_can_network_connect
</fix><fix reboot="false" rule="mount_option_var_log_noexec">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/log || { echo "Not remediating, because there is no record of /var/log in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/log" "noexec" "" ""

	ensure_partition_is_mounted "/var/log"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_execheap" strategy="enable">
var_selinuxuser_execheap="<sub idref="var_selinuxuser_execheap" />"

setsebool -P selinuxuser_execheap $var_selinuxuser_execheap
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_unprivuser_use_svirt" strategy="enable">
var_unprivuser_use_svirt="<sub idref="var_unprivuser_use_svirt" />"

setsebool -P unprivuser_use_svirt $var_unprivuser_use_svirt
</fix><fix rule="sssd_ldap_configure_tls_ca_dir">
var_sssd_ldap_tls_ca_dir="<sub idref="var_sssd_ldap_tls_ca_dir" />"

SSSD_CONF="/etc/sssd/sssd.conf"
LDAP_REGEX='[[:space:]]*\[domain\/[^]]*]([^(\n)]*(\n)+)+?[[:space:]]*ldap_tls_cacertdir'
DOMAIN_REGEX="[[:space:]]*\[domain\/[^]]*]"

# Try find [domain/..] and ldap_tls_cacertdir in sssd.conf, if it exists, set to CA directory
# if it isn't here, add it, if [domain/..] doesn't exist, add it here for default domain
if grep -qzosP $LDAP_REGEX $SSSD_CONF; then
        sed -i "s~ldap_tls_cacertdir[^(\n)]*~ldap_tls_cacertdir = $var_sssd_ldap_tls_ca_dir~" $SSSD_CONF
elif grep -qs $DOMAIN_REGEX $SSSD_CONF; then
        sed -i "/$DOMAIN_REGEX/a ldap_tls_cacertdir = $var_sssd_ldap_tls_ca_dir" $SSSD_CONF
else
        mkdir -p /etc/sssd
        touch $SSSD_CONF
        echo -e "[domain/default]\nldap_tls_cacertdir = $var_sssd_ldap_tls_ca_dir" &gt;&gt; $SSSD_CONF
fi
</fix><fix rule="dconf_gnome_banner_enabled">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/login-screen\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/gdm.d/00-security-settings"
DBDIR="/etc/dconf/db/gdm.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/login-screen]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "banner-message-enable" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*banner-message-enable" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*banner-message-enable\\s*=\\s*.*/banner-message-enable=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/login-screen\\]|a\\banner-message-enable=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/login-screen/banner-message-enable$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/gdm.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/login-screen/banner-message-enable" &gt;&gt; "/etc/dconf/db/gdm.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_gluster_export_all_rw" strategy="enable">
var_gluster_export_all_rw="<sub idref="var_gluster_export_all_rw" />"

setsebool -P gluster_export_all_rw $var_gluster_export_all_rw
</fix><fix rule="clean_components_post_updating">
if grep --silent ^clean_requirements_on_remove /etc/yum.conf ; then
        sed -i "s/^clean_requirements_on_remove.*/clean_requirements_on_remove=1/g" /etc/yum.conf
else
        echo -e "\n# Set clean_requirements_on_remove to 1 per security requirements" &gt;&gt; /etc/yum.conf
        echo "clean_requirements_on_remove=1" &gt;&gt; /etc/yum.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xdm_bind_vnc_tcp_port" strategy="enable">
var_xdm_bind_vnc_tcp_port="<sub idref="var_xdm_bind_vnc_tcp_port" />"

setsebool -P xdm_bind_vnc_tcp_port $var_xdm_bind_vnc_tcp_port
</fix><fix rule="audit_rules_privileged_commands_gpasswd">

PATTERN="-a always,exit -F path=/usr/bin/gpasswd\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="audit_rules_unsuccessful_file_modification_lsetxattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S lsetxattr -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S lsetxattr -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S lsetxattr -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S lsetxattr -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_disable_kerb_auth" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*KerberosAuthentication\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "KerberosAuthentication no" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "KerberosAuthentication no" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix rule="audit_rules_privileged_commands_su">

PATTERN="-a always,exit -F path=/usr/bin/su\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/su -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="require_singleuser_auth">
service_file="/usr/lib/systemd/system/rescue.service"

sulogin="/usr/lib/systemd/systemd-sulogin-shell rescue"

if grep "^ExecStart=.*" "$service_file" ; then
    sed -i "s%^ExecStart=.*%ExecStart=-$sulogin%" "$service_file"
else
    echo "ExecStart=-$sulogin" &gt;&gt; "$service_file"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_zoneminder_run_sudo" strategy="enable">
var_zoneminder_run_sudo="<sub idref="var_zoneminder_run_sudo" />"

setsebool -P zoneminder_run_sudo $var_zoneminder_run_sudo
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_squid_use_tproxy" strategy="enable">
var_squid_use_tproxy="<sub idref="var_squid_use_tproxy" />"

setsebool -P squid_use_tproxy $var_squid_use_tproxy
</fix><fix rule="service_chronyd_or_ntpd_enabled">
if rpm -q --quiet chrony ; then
    if ! /usr/sbin/pidof ntpd ; then
        /usr/bin/systemctl enable "chronyd"
        /usr/bin/systemctl start "chronyd"
        # The service may not be running because it has been started and failed,
        # so let's reset the state so OVAL checks pass.
        # Service should be 'inactive', not 'failed' after reboot though.
        /usr/bin/systemctl reset-failed "chronyd"
    fi
elif rpm -q --quiet ntp ; then
    /usr/bin/systemctl enable "ntpd"
    /usr/bin/systemctl start "ntpd"
    # The service may not be running because it has been started and failed,
    # so let's reset the state so OVAL checks pass.
    # Service should be 'inactive', not 'failed' after reboot though.
    /usr/bin/systemctl reset-failed "ntpd"
else
    if ! rpm -q --quiet "chrony" ; then
        yum install -y "chrony"
    fi
    /usr/bin/systemctl enable "chronyd"
    /usr/bin/systemctl start "chronyd"
    # The service may not be running because it has been started and failed,
    # so let's reset the state so OVAL checks pass.
    # Service should be 'inactive', not 'failed' after reboot though.
    /usr/bin/systemctl reset-failed "chronyd"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_condor_tcp_network_connect" strategy="enable">
var_condor_tcp_network_connect="<sub idref="var_condor_tcp_network_connect" />"

setsebool -P condor_tcp_network_connect $var_condor_tcp_network_connect
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_avahi-daemon_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'avahi-daemon.service'
"$SYSTEMCTL_EXEC" disable 'avahi-daemon.service'
"$SYSTEMCTL_EXEC" mask 'avahi-daemon.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^avahi-daemon.socket'; then
    "$SYSTEMCTL_EXEC" stop 'avahi-daemon.socket'
    "$SYSTEMCTL_EXEC" disable 'avahi-daemon.socket'
    "$SYSTEMCTL_EXEC" mask 'avahi-daemon.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'avahi-daemon.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_glance_use_execmem" strategy="enable">
var_glance_use_execmem="<sub idref="var_glance_use_execmem" />"

setsebool -P glance_use_execmem $var_glance_use_execmem
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_can_connect_zabbix" strategy="enable">
var_httpd_can_connect_zabbix="<sub idref="var_httpd_can_connect_zabbix" />"

setsebool -P httpd_can_connect_zabbix $var_httpd_can_connect_zabbix
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_tipc_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install tipc" /etc/modprobe.d/tipc.conf ; then
	sed -i 's/^install tipc.*/install tipc /bin/true/g' /etc/modprobe.d/tipc.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/tipc.conf
	echo "install tipc /bin/true" &gt;&gt; /etc/modprobe.d/tipc.conf
fi
</fix><fix complexity="low" disruption="low" reboot="true" rule="grub2_disable_interactive_boot" strategy="restrict">
CONFIRM_SPAWN_YES="systemd.confirm_spawn=\(1\|yes\|true\|on\)"
CONFIRM_SPAWN_NO="systemd.confirm_spawn=no"

if grep -q "\(GRUB_CMDLINE_LINUX\|GRUB_CMDLINE_LINUX_DEFAULT\)" /etc/default/grub
then
	sed -i "s/${CONFIRM_SPAWN_YES}/${CONFIRM_SPAWN_NO}/" /etc/default/grub
fi
# Remove 'systemd.confirm_spawn' kernel argument also from runtime settings
/sbin/grubby --update-kernel=ALL --remove-args="systemd.confirm_spawn"
</fix><fix rule="file_ownership_library_dirs">for LIBDIR in /usr/lib /usr/lib64 /lib /lib64
do
  if [ -d $LIBDIR ]
  then
    find -L $LIBDIR \! -user root -exec chown root {} \; 
  fi
done
</fix><fix rule="rpm_verify_hashes">
# Find which files have incorrect hash (not in /etc, because there are all system related config. files) and then get files names
files_with_incorrect_hash="$(rpm -Va | grep -E '^..5.* /(bin|sbin|lib|lib64|usr)/' | awk '{print $NF}' )"
# From files names get package names and change newline to space, because rpm writes each package to new line
packages_to_reinstall="$(rpm -qf $files_with_incorrect_hash | tr '\n' ' ')"

yum reinstall -y $packages_to_reinstall
</fix><fix rule="audit_rules_file_deletion_events">

# Perform the remediation for the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S .* -F auid&gt;=1000 -F auid!=unset -k *"
	# Use escaped BRE regex to specify rule group
	GROUP="\(rmdir\|unlink\|rename\)"
	FULL_RULE="-a always,exit -F arch=$ARCH -S rmdir -S unlink -S unlinkat -S rename -S renameat -F auid&gt;=1000 -F auid!=unset -k delete"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_cron_daily" strategy="configure">
chmod 0700 /etc/cron.daily/
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_usbguard_installed" strategy="enable">
if ! rpm -q --quiet "usbguard" ; then
    yum install -y "usbguard"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_subscription-manager_installed" strategy="enable">
if ! rpm -q --quiet "subscription-manager" ; then
    yum install -y "subscription-manager"
fi
</fix><fix rule="audit_rules_kernel_module_loading">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
# Note: 32-bit and 64-bit kernel syscall numbers not always line up =&gt;
#       it's required on a 64-bit system to check also for the presence
#       of 32-bit's equivalent of the corresponding rule.
#       (See `man 7 audit.rules` for details )
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
        GROUP="modules"

        PATTERN="-a always,exit -F arch=$ARCH -S init_module -S delete_module -S finit_module \(-F key=\|-k \).*"
        FULL_RULE="-a always,exit -F arch=$ARCH -S init_module -S delete_module -S finit_module -k modules"

        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="accounts_minimum_age_login_defs">
var_accounts_minimum_age_login_defs="<sub idref="var_accounts_minimum_age_login_defs" />"

grep -q ^PASS_MIN_DAYS /etc/login.defs &amp;&amp; \
  sed -i "s/PASS_MIN_DAYS.*/PASS_MIN_DAYS     $var_accounts_minimum_age_login_defs/g" /etc/login.defs
if ! [ $? -eq 0 ]; then
    echo "PASS_MIN_DAYS      $var_accounts_minimum_age_login_defs" &gt;&gt; /etc/login.defs
fi
</fix><fix rule="audit_rules_kernel_module_loading_init">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
# Note: 32-bit and 64-bit kernel syscall numbers not always line up =&gt;
#       it's required on a 64-bit system to check also for the presence
#       of 32-bit's equivalent of the corresponding rule.
#       (See `man 7 audit.rules` for details )
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S init_module \(-F key=\|-k \).*"
	GROUP="modules"
	FULL_RULE="-a always,exit -F arch=$ARCH -S init_module -k modules"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="high" disruption="medium" reboot="false" rule="rpm_verify_permissions" strategy="restrict">
# Declare array to hold set of RPM packages we need to correct permissions for
declare -A SETPERMS_RPM_DICT

# Create a list of files on the system having permissions different from what
# is expected by the RPM database
readarray -t FILES_WITH_INCORRECT_PERMS &lt; &lt;(rpm -Va --nofiledigest | awk '{ if (substr($0,2,1)=="M") print $NF }')

for FILE_PATH in "${FILES_WITH_INCORRECT_PERMS[@]}"
do
	RPM_PACKAGE=$(rpm -qf "$FILE_PATH")
	# Use an associative array to store packages as it's keys, not having to care about duplicates.
	SETPERMS_RPM_DICT["$RPM_PACKAGE"]=1
done

# For each of the RPM packages left in the list -- reset its permissions to the
# correct values
for RPM_PACKAGE in "${!SETPERMS_RPM_DICT[@]}"
do
	rpm --setperms "${RPM_PACKAGE}"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_use_usb" strategy="enable">
var_virt_use_usb="<sub idref="var_virt_use_usb" />"

setsebool -P virt_use_usb $var_virt_use_usb
</fix><fix rule="audit_rules_privileged_commands_unix_chkpwd">

PATTERN="-a always,exit -F path=/usr/sbin/unix_chkpwd\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="gnome_gdm_disable_guest_login">
if rpm --quiet -q gdm
then
	if ! grep -q "^TimedLoginEnable=" /etc/gdm/custom.conf
	then
		sed -i "/^\[daemon\]/a \
		TimedLoginEnable=False" /etc/gdm/custom.conf
	else
		sed -i "s/^TimedLoginEnable=.*/TimedLoginEnable=False/g" /etc/gdm/custom.conf
	fi
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_direct_dri_enabled" strategy="enable">
var_selinuxuser_direct_dri_enabled="<sub idref="var_selinuxuser_direct_dri_enabled" />"

setsebool -P selinuxuser_direct_dri_enabled $var_selinuxuser_direct_dri_enabled
</fix><fix rule="audit_rules_sysadmin_actions">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/sudoers" "wa" "actions"
fix_audit_watch_rule "augenrules" "/etc/sudoers" "wa" "actions"
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/sudoers.d" "wa" "actions"
fix_audit_watch_rule "augenrules" "/etc/sudoers.d" "wa" "actions"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_allow_only_protocol2" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*Protocol\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "Protocol 2" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "Protocol 2" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_etc_passwd" strategy="configure">
chmod 0644 /etc/passwd
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_logadm_exec_content" strategy="enable">
var_logadm_exec_content="<sub idref="var_logadm_exec_content" />"

setsebool -P logadm_exec_content $var_logadm_exec_content
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_pcp_bind_all_unreserved_ports" strategy="enable">
var_pcp_bind_all_unreserved_ports="<sub idref="var_pcp_bind_all_unreserved_ports" />"

setsebool -P pcp_bind_all_unreserved_ports $var_pcp_bind_all_unreserved_ports
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_neutron_can_network" strategy="enable">
var_neutron_can_network="<sub idref="var_neutron_can_network" />"

setsebool -P neutron_can_network $var_neutron_can_network
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_telnetd-ssl_removed" strategy="disable">
# CAUTION: This remediation script will remove telnetd-ssl
#	   from the system, and may remove any packages
#	   that depend on telnetd-ssl. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "telnetd-ssl" ; then
    yum remove -y "telnetd-ssl"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_manage_ipa" strategy="enable">
var_httpd_manage_ipa="<sub idref="var_httpd_manage_ipa" />"

setsebool -P httpd_manage_ipa $var_httpd_manage_ipa
</fix><fix rule="configure_crypto_policy">
var_system_crypto_policy="<sub idref="var_system_crypto_policy" />"

update-crypto-policies --set ${var_system_crypto_policy}
</fix><fix rule="no_host_based_files">
# Identify local mounts
MOUNT_LIST=$(df --local | awk '{ print $6 }')

# Find file on each listed mount point
for cur_mount in ${MOUNT_LIST}
do
	find ${cur_mount} -xdev -type f -name "shosts.equiv" -exec rm -f {} \;
done
</fix><fix rule="grub2_audit_argument">

#in later versions of rhel grub2-editenv is used
grub2-editenv - set "$(grub2-editenv - list | grep kernelopts) audit=1"
</fix><fix rule="configure_tmux_lock_after_time">
tmux_conf="/etc/tmux.conf"

if grep -qP '^\s*set\s+-g\s+lock-after-time' "$tmux_conf" ; then
    sed -i 's/^\s*set\s\+-g\s\+lock-after-time.*$/set -g lock-after-time 900/' "$tmux_conf"
else
    echo "set -g lock-after-time 900" &gt;&gt; "$tmux_conf"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_can_network_connect" strategy="enable">
var_httpd_can_network_connect="<sub idref="var_httpd_can_network_connect" />"

setsebool -P httpd_can_network_connect $var_httpd_can_network_connect
</fix><fix rule="configure_ssh_crypto_policy">
SSH_CONF="/etc/sysconfig/sshd"

sed -i "/^\s*CRYPTO_POLICY.*$/d" $SSH_CONF
</fix><fix rule="auditd_data_retention_max_log_file_action">
var_auditd_max_log_file_action="<sub idref="var_auditd_max_log_file_action" />"

AUDITCONFIG=/etc/audit/auditd.conf
<sub idref="function_replace_or_append" />
replace_or_append $AUDITCONFIG '^max_log_file_action' "$var_auditd_max_log_file_action" "@CCENUM@"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_cron_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'cron.service'
"$SYSTEMCTL_EXEC" enable 'cron.service'
</fix><fix reboot="false" rule="mount_option_home_nosuid">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /home || { echo "Not remediating, because there is no record of /home in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/home" "nosuid" "" ""

	ensure_partition_is_mounted "/home"
}

perform_remediation
</fix><fix rule="audit_rules_usergroup_modification_passwd">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/passwd" "wa" "audit_rules_usergroup_modification"
fix_audit_watch_rule "augenrules" "/etc/passwd" "wa" "audit_rules_usergroup_modification"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_dbus_avahi" strategy="enable">
var_httpd_dbus_avahi="<sub idref="var_httpd_dbus_avahi" />"

setsebool -P httpd_dbus_avahi $var_httpd_dbus_avahi
</fix><fix rule="audit_rules_media_export">

# Perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S .* -F auid&gt;=1000 -F auid!=unset -k *"
	GROUP="mount"
	FULL_RULE="-a always,exit -F arch=$ARCH -S mount -F auid&gt;=1000 -F auid!=unset -k export"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_swift_can_network" strategy="enable">
var_swift_can_network="<sub idref="var_swift_can_network" />"

setsebool -P swift_can_network $var_swift_can_network
</fix><fix rule="audit_rules_privileged_commands_postqueue">

PATTERN="-a always,exit -F path=/usr/sbin/postqueue\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/sbin/postqueue -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_rsh-server_removed" strategy="disable">
# CAUTION: This remediation script will remove rsh-server
#	   from the system, and may remove any packages
#	   that depend on rsh-server. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "rsh-server" ; then
    yum remove -y "rsh-server"
fi
</fix><fix rule="configure_openssl_crypto_policy">
OPENSSL_CRYPTO_POLICY_SECTION='[ crypto_policy ]'
OPENSSL_CRYPTO_POLICY_SECTION_REGEX='\[\s*crypto_policy\s*\]'
OPENSSL_CRYPTO_POLICY_INCLUSION='.include /etc/crypto-policies/back-ends/openssl.config'
OPENSSL_CRYPTO_POLICY_INCLUSION_REGEX='^\s*\.include\s*/etc/crypto-policies/back-ends/openssl.config$'

function remediate_openssl_crypto_policy() {
	CONFIG_FILE="/etc/pki/tls/openssl.cnf"
	if test -f "$CONFIG_FILE"; then
		if ! grep -q "^\\s*$OPENSSL_CRYPTO_POLICY_SECTION_REGEX" "$CONFIG_FILE"; then
			printf '\n%s\n\n%s' "$OPENSSL_CRYPTO_POLICY_SECTION" "$OPENSSL_CRYPTO_POLICY_INCLUSION" &gt;&gt; "$CONFIG_FILE"
			return 0
		elif ! grep -q "^\\s*$OPENSSL_CRYPTO_POLICY_INCLUSION_REGEX" "$CONFIG_FILE"; then
			sed -i "s|$OPENSSL_CRYPTO_POLICY_SECTION_REGEX|&amp;\\n\\n$OPENSSL_CRYPTO_POLICY_INCLUSION\\n|" "$CONFIG_FILE"
			return 0
		fi
	else
		echo "Aborting remediation as '$CONFIG_FILE' was not even found." &gt;&amp;2
		return 1
	fi
}

remediate_openssl_crypto_policy
</fix><fix rule="mount_option_nodev_remote_filesystems">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

ensure_mount_option_for_vfstype "nfs[4]?" "nodev" "" "nfs4"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_use_nfs" strategy="enable">
var_httpd_use_nfs="<sub idref="var_httpd_use_nfs" />"

setsebool -P httpd_use_nfs $var_httpd_use_nfs
</fix><fix rule="sshd_disable_rhosts_rsa">
<sub idref="function_replace_or_append" />
replace_or_append '/etc/ssh/sshd_config' '^RhostsRSAAuthentication' 'no' '@CCENUM@' '%s %s'
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_kernel_perf_event_paranoid" strategy="disable">

#
# Set runtime for kernel.perf_event_paranoid
#
/sbin/sysctl -q -n -w kernel.perf_event_paranoid="2"

#
# If kernel.perf_event_paranoid present in /etc/sysctl.conf, change value to "2"
#	else, add "kernel.perf_event_paranoid = 2" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^kernel.perf_event_paranoid' "2" '@CCENUM@'
</fix><fix rule="ensure_redhat_gpgkey_installed"># The two fingerprints below are retrieved from https://access.redhat.com/security/team/key
readonly REDHAT_RELEASE_FINGERPRINT="567E347AD0044ADE55BA8A5F199E2F91FD431D51"
readonly REDHAT_AUXILIARY_FINGERPRINT="6A6AA7C97C8890AEC6AEBFE2F76F66C3D4082792"

# Location of the key we would like to import (once it's integrity verified)
readonly REDHAT_RELEASE_KEY="/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release"

RPM_GPG_DIR_PERMS=$(stat -c %a "$(dirname "$REDHAT_RELEASE_KEY")")

# Verify /etc/pki/rpm-gpg directory permissions are safe
if [ "${RPM_GPG_DIR_PERMS}" -le "755" ]
then
  # If they are safe, try to obtain fingerprints from the key file
  # (to ensure there won't be e.g. CRC error).

  readarray -t GPG_OUT &lt; &lt;(gpg --show-keys --with-fingerprint --with-colons "$REDHAT_RELEASE_KEY" | grep -A1 "^pub" | grep "^fpr" | cut -d ":" -f 10)

  GPG_RESULT=$?
  # No CRC error, safe to proceed
  if [ "${GPG_RESULT}" -eq "0" ]
  then
    echo "${GPG_OUT[*]}" | grep -vE "${REDHAT_RELEASE_FINGERPRINT}|${REDHAT_AUXILIARY_FINGERPRINT}" || {
      # If $REDHAT_RELEASE_KEY file doesn't contain any keys with unknown fingerprint, import it
      rpm --import "${REDHAT_RELEASE_KEY}"
    }
  fi
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_sandbox_use_audit" strategy="enable">
var_virt_sandbox_use_audit="<sub idref="var_virt_sandbox_use_audit" />"

setsebool -P virt_sandbox_use_audit $var_virt_sandbox_use_audit
</fix><fix rule="dconf_gnome_screensaver_mode_blank">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/desktop/screensaver\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/desktop/screensaver]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "picture-uri" "string ''" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "string ''")"
    if grep -q "^\\s*picture-uri" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*picture-uri\\s*=\\s*.*/picture-uri=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/desktop/screensaver\\]|a\\picture-uri=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/screensaver/picture-uri$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/screensaver/picture-uri" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix rule="dconf_gnome_screensaver_idle_activation_locked">

# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/screensaver/idle-activation-enabled$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/screensaver/idle-activation-enabled" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ftpd_use_nfs" strategy="enable">
var_ftpd_use_nfs="<sub idref="var_ftpd_use_nfs" />"

setsebool -P ftpd_use_nfs $var_ftpd_use_nfs
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_cron_weekly" strategy="configure">

chgrp 0 /etc/cron.weekly/
</fix><fix rule="disable_users_coredumps">SECURITY_LIMITS_FILE="/etc/security/limits.conf"

if grep -qE '\*\s+hard\s+core' $SECURITY_LIMITS_FILE; then
        sed -ri 's/(hard\s+core\s+)[[:digit:]]+/\1 0/' $SECURITY_LIMITS_FILE
else
        echo "*     hard   core    0" &gt;&gt; $SECURITY_LIMITS_FILE
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xguest_mount_media" strategy="enable">
var_xguest_mount_media="<sub idref="var_xguest_mount_media" />"

setsebool -P xguest_mount_media $var_xguest_mount_media
</fix><fix rule="dconf_gnome_disable_restart_shutdown">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/login-screen\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/gdm.d/00-security-settings"
DBDIR="/etc/dconf/db/gdm.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/login-screen]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "disable-restart-buttons" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*disable-restart-buttons" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*disable-restart-buttons\\s*=\\s*.*/disable-restart-buttons=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/login-screen\\]|a\\disable-restart-buttons=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/login-screen/disable-restart-buttons$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/gdm.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/login-screen/disable-restart-buttons" &gt;&gt; "/etc/dconf/db/gdm.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_mysql_connect_enabled" strategy="enable">
var_selinuxuser_mysql_connect_enabled="<sub idref="var_selinuxuser_mysql_connect_enabled" />"

setsebool -P selinuxuser_mysql_connect_enabled $var_selinuxuser_mysql_connect_enabled
</fix><fix rule="umask_for_daemons">
var_umask_for_daemons="<sub idref="var_umask_for_daemons" />"

grep -q ^umask /etc/init.d/functions &amp;&amp; \
  sed -i "s/umask.*/umask $var_umask_for_daemons/g" /etc/init.d/functions
if ! [ $? -eq 0 ]; then
    echo "umask $var_umask_for_daemons" &gt;&gt; /etc/init.d/functions
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_spamd_enable_home_dirs" strategy="enable">
var_spamd_enable_home_dirs="<sub idref="var_spamd_enable_home_dirs" />"

setsebool -P spamd_enable_home_dirs $var_spamd_enable_home_dirs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_dbadm_manage_user_files" strategy="enable">
var_dbadm_manage_user_files="<sub idref="var_dbadm_manage_user_files" />"

setsebool -P dbadm_manage_user_files $var_dbadm_manage_user_files
</fix><fix rule="configure_fapolicyd_mounts">
MISSING_MOUNTS=$( mount | awk '$3 !~ /^\/(sys|run$)/ &amp;&amp; $5 ~ /^(tmpfs|ext4|ext3|xfs)$/ { print $3 }' )
if [ -f /etc/fapolicyd/fapolicyd.mounts ] ; then
	MISSING_MOUNTS=$( echo "$MISSING_MOUNTS" | grep -vxf /etc/fapolicyd/fapolicyd.mounts )
fi
if [ -n "$MISSING_MOUNTS" ] ; then
	echo "$MISSING_MOUNTS" &gt;&gt; /etc/fapolicyd/fapolicyd.mounts
fi
</fix><fix rule="audit_rules_unsuccessful_file_modification_fchownat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fchownat -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fchownat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S fchownat -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S fchownat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_git_system_use_nfs" strategy="enable">
var_git_system_use_nfs="<sub idref="var_git_system_use_nfs" />"

setsebool -P git_system_use_nfs $var_git_system_use_nfs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_use_openstack" strategy="enable">
var_httpd_use_openstack="<sub idref="var_httpd_use_openstack" />"

setsebool -P httpd_use_openstack $var_httpd_use_openstack
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_usbguard_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'usbguard.service'
"$SYSTEMCTL_EXEC" enable 'usbguard.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_sanlock_use_fusefs" strategy="enable">
var_sanlock_use_fusefs="<sub idref="var_sanlock_use_fusefs" />"

setsebool -P sanlock_use_fusefs $var_sanlock_use_fusefs
</fix><fix complexity="low" disruption="low" reboot="false" rule="configure_firewalld_ports" strategy="configure">

if ! rpm -q --quiet "firewalld" ; then
    yum install -y "firewalld"
fi
firewalld_sshd_zone="<sub idref="firewalld_sshd_zone" />"

# This assumes that firewalld_sshd_zone is one of the pre-defined zones
if [ ! -f /etc/firewalld/zones/${firewalld_sshd_zone}.xml ]; then
    cp /usr/lib/firewalld/zones/${firewalld_sshd_zone}.xml /etc/firewalld/zones/${firewalld_sshd_zone}.xml
fi
if ! grep -q 'service name="ssh"' /etc/firewalld/zones/${firewalld_sshd_zone}.xml; then
    sed -i '/&lt;\/description&gt;/a \
  &lt;service name="ssh"/&gt;' /etc/firewalld/zones/${firewalld_sshd_zone}.xml
fi

# Check if any eth interface is bounded to the zone with SSH service enabled
nic_bound=false
eth_interface_list=$(ip link show up | cut -d ' ' -f2 | cut -d ':' -s -f1 | grep -E '^(en|eth)')
for interface in $eth_interface_list; do
    if grep -q "ZONE=$firewalld_sshd_zone" /etc/sysconfig/network-scripts/ifcfg-$interface; then
        nic_bound=true
        break;
    fi
done

if [ $nic_bound = false ];then
    # Add first NIC to SSH enabled zone

    if ! firewall-cmd --state -q; then
<sub idref="function_replace_or_append" />
        replace_or_append "/etc/sysconfig/network-scripts/ifcfg-${eth_interface_list[0]}" '^ZONE=' "$firewalld_sshd_zone" '@CCENUM@' '%s=%s'
    else
        # If firewalld service is running, we need to do this step with firewall-cmd
        # Otherwise firewalld will comunicate with NetworkManage and will revert assigned zone
        # of NetworkManager managed interfaces upon reload
        firewall-cmd --zone=$firewalld_sshd_zone --add-interface=${eth_interface_list[0]}
        firewall-cmd --reload
    fi
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_git_cgi_enable_homedirs" strategy="enable">
var_git_cgi_enable_homedirs="<sub idref="var_git_cgi_enable_homedirs" />"

setsebool -P git_cgi_enable_homedirs $var_git_cgi_enable_homedirs
</fix><fix rule="audit_rules_time_adjtimex">
<sub idref="function_perform_audit_adjtimex_settimeofday_stime_remediation" />
perform_audit_adjtimex_settimeofday_stime_remediation
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_firewire-core_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install firewire-core" /etc/modprobe.d/firewire-core.conf ; then
	sed -i 's/^install firewire-core.*/install firewire-core /bin/true/g' /etc/modprobe.d/firewire-core.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/firewire-core.conf
	echo "install firewire-core /bin/true" &gt;&gt; /etc/modprobe.d/firewire-core.conf
fi
</fix><fix rule="smartcard_configure_cert_checking">
# Install required packages
if ! rpm --quiet -q pam_pkcs11; then yum -y -d 1 install pam_pkcs11; fi

if grep "^\s*cert_policy" /etc/pam_pkcs11/pam_pkcs11.conf | grep -qv "ocsp_on"; then
	sed -i "/^\s*#/! s/cert_policy.*/cert_policy = ca, ocsp_on, signature;/g" /etc/pam_pkcs11/pam_pkcs11.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_grub2_cfg" strategy="configure">

chown 0 /boot/grub2/grub.cfg
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_pppd_can_insmod" strategy="enable">
var_pppd_can_insmod="<sub idref="var_pppd_can_insmod" />"

setsebool -P pppd_can_insmod $var_pppd_can_insmod
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mailman_use_fusefs" strategy="enable">
var_mailman_use_fusefs="<sub idref="var_mailman_use_fusefs" />"

setsebool -P mailman_use_fusefs $var_mailman_use_fusefs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mozilla_plugin_bind_unreserved_ports" strategy="enable">
var_mozilla_plugin_bind_unreserved_ports="<sub idref="var_mozilla_plugin_bind_unreserved_ports" />"

setsebool -P mozilla_plugin_bind_unreserved_ports $var_mozilla_plugin_bind_unreserved_ports
</fix><fix rule="grub2_slub_debug_argument">

#in later versions of rhel grub2-editenv is used
grub2-editenv - set "$(grub2-editenv - list | grep kernelopts) slub_debug=P"
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_policycoreutils_installed" strategy="enable">
if ! rpm -q --quiet "policycoreutils" ; then
    yum install -y "policycoreutils"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_talk-server_removed" strategy="disable">
# CAUTION: This remediation script will remove talk-server
#	   from the system, and may remove any packages
#	   that depend on talk-server. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "talk-server" ; then
    yum remove -y "talk-server"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_rw_qemu_ga_data" strategy="enable">
var_virt_rw_qemu_ga_data="<sub idref="var_virt_rw_qemu_ga_data" />"

setsebool -P virt_rw_qemu_ga_data $var_virt_rw_qemu_ga_data
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_cron_installed" strategy="enable">
if ! rpm -q --quiet "cron" ; then
    yum install -y "cron"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_zabbix_can_network" strategy="enable">
var_zabbix_can_network="<sub idref="var_zabbix_can_network" />"

setsebool -P zabbix_can_network $var_zabbix_can_network
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_gluster_anon_write" strategy="enable">
var_gluster_anon_write="<sub idref="var_gluster_anon_write" />"

setsebool -P gluster_anon_write $var_gluster_anon_write
</fix><fix rule="configure_bashrc_exec_tmux">
if ! grep -x '  case "$name" in sshd|login) exec tmux ;; esac' /etc/bashrc; then
    cat &gt;&gt; /etc/bashrc &lt;&lt;'EOF'
if [ "$PS1" ]; then
  parent=$(ps -o ppid= -p $$)
  name=$(ps -o comm= -p $parent)
  case "$name" in sshd|login) exec tmux ;; esac
fi
EOF
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_pigz_removed" strategy="disable">
# CAUTION: This remediation script will remove pigz
#	   from the system, and may remove any packages
#	   that depend on pigz. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "pigz" ; then
    yum remove -y "pigz"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_aide_installed" strategy="enable">
if ! rpm -q --quiet "aide" ; then
    yum install -y "aide"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_gdm_removed" strategy="disable">
# CAUTION: This remediation script will remove gdm
#	   from the system, and may remove any packages
#	   that depend on gdm. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "gdm" ; then
    yum remove -y "gdm"
fi
</fix><fix rule="audit_rules_unsuccessful_file_modification_lremovexattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S lremovexattr -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S lremovexattr -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S lremovexattr -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S lremovexattr -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mount_anyfile" strategy="enable">
var_mount_anyfile="<sub idref="var_mount_anyfile" />"

setsebool -P mount_anyfile $var_mount_anyfile
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rexec_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rexec.service'
"$SYSTEMCTL_EXEC" disable 'rexec.service'
"$SYSTEMCTL_EXEC" mask 'rexec.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rexec.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rexec.socket'
    "$SYSTEMCTL_EXEC" disable 'rexec.socket'
    "$SYSTEMCTL_EXEC" mask 'rexec.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rexec.service' || true
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_can_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install can" /etc/modprobe.d/can.conf ; then
	sed -i 's/^install can.*/install can /bin/true/g' /etc/modprobe.d/can.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/can.conf
	echo "install can /bin/true" &gt;&gt; /etc/modprobe.d/can.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_sanlock_use_nfs" strategy="enable">
var_sanlock_use_nfs="<sub idref="var_sanlock_use_nfs" />"

setsebool -P sanlock_use_nfs $var_sanlock_use_nfs
</fix><fix rule="audit_rules_unsuccessful_file_modification_openat">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_use_nfs_home_dirs" strategy="enable">
var_use_nfs_home_dirs="<sub idref="var_use_nfs_home_dirs" />"

setsebool -P use_nfs_home_dirs $var_use_nfs_home_dirs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_telepathy_tcp_connect_generic_network_ports" strategy="enable">
var_telepathy_tcp_connect_generic_network_ports="<sub idref="var_telepathy_tcp_connect_generic_network_ports" />"

setsebool -P telepathy_tcp_connect_generic_network_ports $var_telepathy_tcp_connect_generic_network_ports
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_awstats_purge_apache_log_files" strategy="enable">
var_awstats_purge_apache_log_files="<sub idref="var_awstats_purge_apache_log_files" />"

setsebool -P awstats_purge_apache_log_files $var_awstats_purge_apache_log_files
</fix><fix rule="audit_rules_dac_modification_fchownat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fchownat.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mmap_low_allowed" strategy="enable">
var_mmap_low_allowed="<sub idref="var_mmap_low_allowed" />"

setsebool -P mmap_low_allowed $var_mmap_low_allowed
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_can_connect_ftp" strategy="enable">
var_httpd_can_connect_ftp="<sub idref="var_httpd_can_connect_ftp" />"

setsebool -P httpd_can_connect_ftp $var_httpd_can_connect_ftp
</fix><fix rule="grub2_audit_backlog_limit_argument">

#in later versions of rhel grub2-editenv is used
grub2-editenv - set "$(grub2-editenv - list | grep kernelopts) audit_backlog_limit=8192"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_polipo_session_users" strategy="enable">
var_polipo_session_users="<sub idref="var_polipo_session_users" />"

setsebool -P polipo_session_users $var_polipo_session_users
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_nfs_export_all_rw" strategy="enable">
var_nfs_export_all_rw="<sub idref="var_nfs_export_all_rw" />"

setsebool -P nfs_export_all_rw $var_nfs_export_all_rw
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_daemons_use_tty" strategy="enable">
var_daemons_use_tty="<sub idref="var_daemons_use_tty" />"

setsebool -P daemons_use_tty $var_daemons_use_tty
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_fapolicyd_installed" strategy="enable">
if ! rpm -q --quiet "fapolicyd" ; then
    yum install -y "fapolicyd"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_unconfined_chrome_sandbox_transition" strategy="enable">
var_unconfined_chrome_sandbox_transition="<sub idref="var_unconfined_chrome_sandbox_transition" />"

setsebool -P unconfined_chrome_sandbox_transition $var_unconfined_chrome_sandbox_transition
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_kernel_randomize_va_space" strategy="disable">

#
# Set runtime for kernel.randomize_va_space
#
/sbin/sysctl -q -n -w kernel.randomize_va_space="2"

#
# If kernel.randomize_va_space present in /etc/sysctl.conf, change value to "2"
#	else, add "kernel.randomize_va_space = 2" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^kernel.randomize_va_space' "2" '@CCENUM@'
</fix><fix reboot="false" rule="mount_option_boot_nosuid">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /boot || { echo "Not remediating, because there is no record of /boot in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/boot" "nosuid" "" ""

	ensure_partition_is_mounted "/boot"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_crontab" strategy="configure">

chgrp 0 /etc/crontab
</fix><fix rule="audit_rules_usergroup_modification_gshadow">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/gshadow" "wa" "audit_rules_usergroup_modification"
fix_audit_watch_rule "augenrules" "/etc/gshadow" "wa" "audit_rules_usergroup_modification"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_use_priv_separation" strategy="restrict">
var_sshd_priv_separation="<sub idref="var_sshd_priv_separation" />"

if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*UsePrivilegeSeparation\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "UsePrivilegeSeparation $var_sshd_priv_separation" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "UsePrivilegeSeparation $var_sshd_priv_separation" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_fapolicyd_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'fapolicyd.service'
"$SYSTEMCTL_EXEC" enable 'fapolicyd.service'
</fix><fix reboot="false" rule="mount_option_tmp_nodev">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /tmp || { echo "Not remediating, because there is no record of /tmp in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/tmp" "nodev" "" ""

	ensure_partition_is_mounted "/tmp"
}

perform_remediation
</fix><fix complexity="low" disruption="high" reboot="true" rule="security_patches_up_to_date" strategy="patch">yum -y update
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_krb5-workstation_removed" strategy="disable">
# CAUTION: This remediation script will remove krb5-workstation
#	   from the system, and may remove any packages
#	   that depend on krb5-workstation. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "krb5-workstation" ; then
    yum remove -y "krb5-workstation"
fi
</fix><fix rule="set_password_hashing_algorithm_libuserconf">
LIBUSER_CONF="/etc/libuser.conf"
CRYPT_STYLE_REGEX='[[:space:]]*\[defaults](.*(\n)+)+?[[:space:]]*crypt_style[[:space:]]*'

# Try find crypt_style in [defaults] section. If it is here, then change algorithm to sha512.
# If it isn't here, then add it to [defaults] section.
if grep -qzosP $CRYPT_STYLE_REGEX $LIBUSER_CONF ; then
        sed -i "s/\(crypt_style[[:space:]]*=[[:space:]]*\).*/\1sha512/g" $LIBUSER_CONF
elif grep -qs "\[defaults]" $LIBUSER_CONF ; then
        sed -i "/[[:space:]]*\[defaults]/a crypt_style = sha512" $LIBUSER_CONF
else
        echo -e "[defaults]\ncrypt_style = sha512" &gt;&gt; $LIBUSER_CONF
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_saslauthd_read_shadow" strategy="enable">
var_saslauthd_read_shadow="<sub idref="var_saslauthd_read_shadow" />"

setsebool -P saslauthd_read_shadow $var_saslauthd_read_shadow
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_gpg_web_anon_write" strategy="enable">
var_gpg_web_anon_write="<sub idref="var_gpg_web_anon_write" />"

setsebool -P gpg_web_anon_write $var_gpg_web_anon_write
</fix><fix complexity="low" disruption="low" reboot="true" rule="configure_kerberos_crypto_policy" strategy="configure">
rm -f /etc/krb5.conf.d/crypto-policies
ln -s /etc/crypto-policies/back-ends/krb5.config /etc/krb5.conf.d/crypto-policies
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_syslogng_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'syslogng.service'
"$SYSTEMCTL_EXEC" enable 'syslogng.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_ntp_installed" strategy="enable">
if ! rpm -q --quiet "ntp" ; then
    yum install -y "ntp"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="accounts_password_pam_maxrepeat" strategy="restrict">
var_password_pam_maxrepeat="<sub idref="var_password_pam_maxrepeat" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/security/pwquality.conf' '^maxrepeat' $var_password_pam_maxrepeat '@CCENUM@' '%s = %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_kerberos_enabled" strategy="enable">
var_kerberos_enabled="<sub idref="var_kerberos_enabled" />"

setsebool -P kerberos_enabled $var_kerberos_enabled
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_gluster_export_all_ro" strategy="enable">
var_gluster_export_all_ro="<sub idref="var_gluster_export_all_ro" />"

setsebool -P gluster_export_all_ro $var_gluster_export_all_ro
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_tmpreaper_use_nfs" strategy="enable">
var_tmpreaper_use_nfs="<sub idref="var_tmpreaper_use_nfs" />"

setsebool -P tmpreaper_use_nfs $var_tmpreaper_use_nfs
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_samba_removed" strategy="disable">
# CAUTION: This remediation script will remove samba
#	   from the system, and may remove any packages
#	   that depend on samba. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "samba" ; then
    yum remove -y "samba"
fi
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_hfs_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install hfs" /etc/modprobe.d/hfs.conf ; then
	sed -i 's/^install hfs.*/install hfs /bin/true/g' /etc/modprobe.d/hfs.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/hfs.conf
	echo "install hfs /bin/true" &gt;&gt; /etc/modprobe.d/hfs.conf
fi
</fix><fix reboot="false" rule="mount_option_boot_nodev">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /boot || { echo "Not remediating, because there is no record of /boot in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/boot" "nodev" "" ""

	ensure_partition_is_mounted "/boot"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_etc_gshadow" strategy="configure">
chmod 0000 /etc/gshadow
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_sge_domain_can_network_connect" strategy="enable">
var_sge_domain_can_network_connect="<sub idref="var_sge_domain_can_network_connect" />"

setsebool -P sge_domain_can_network_connect $var_sge_domain_can_network_connect
</fix><fix rule="audit_rules_unsuccessful_file_modification_chmod">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S chmod -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S chmod -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S chmod -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S chmod -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_abrt-cli_removed" strategy="disable">
# CAUTION: This remediation script will remove abrt-cli
#	   from the system, and may remove any packages
#	   that depend on abrt-cli. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "abrt-cli" ; then
    yum remove -y "abrt-cli"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_netfs_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'netfs.service'
"$SYSTEMCTL_EXEC" disable 'netfs.service'
"$SYSTEMCTL_EXEC" mask 'netfs.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^netfs.socket'; then
    "$SYSTEMCTL_EXEC" stop 'netfs.socket'
    "$SYSTEMCTL_EXEC" disable 'netfs.socket'
    "$SYSTEMCTL_EXEC" mask 'netfs.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'netfs.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_use_ecryptfs_home_dirs" strategy="enable">
var_use_ecryptfs_home_dirs="<sub idref="var_use_ecryptfs_home_dirs" />"

setsebool -P use_ecryptfs_home_dirs $var_use_ecryptfs_home_dirs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ftpd_use_cifs" strategy="enable">
var_ftpd_use_cifs="<sub idref="var_ftpd_use_cifs" />"

setsebool -P ftpd_use_cifs $var_ftpd_use_cifs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_verify_dns" strategy="enable">
var_httpd_verify_dns="<sub idref="var_httpd_verify_dns" />"

setsebool -P httpd_verify_dns $var_httpd_verify_dns
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_openshift_use_nfs" strategy="enable">
var_openshift_use_nfs="<sub idref="var_openshift_use_nfs" />"

setsebool -P openshift_use_nfs $var_openshift_use_nfs
</fix><fix rule="audit_rules_execution_seunshare">

PATTERN="-a always,exit -F path=/usr/sbin/seunshare\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/sbin/seunshare -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_etc_gshadow" strategy="configure">

chown 0 /etc/gshadow
</fix><fix reboot="false" rule="mount_option_var_tmp_noexec">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/tmp || { echo "Not remediating, because there is no record of /var/tmp in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/tmp" "noexec" "" ""

	ensure_partition_is_mounted "/var/tmp"
}

perform_remediation
</fix><fix reboot="false" rule="mount_option_var_log_audit_nosuid">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/log/audit || { echo "Not remediating, because there is no record of /var/log/audit in /etc/fstab" &gt;&amp;2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/log/audit" "nosuid" "" ""

	ensure_partition_is_mounted "/var/log/audit"
}

perform_remediation
</fix><fix complexity="low" disruption="low" reboot="false" rule="auditd_freq" strategy="restrict">if [ -e "/etc/audit/auditd.conf" ] ; then
    LC_ALL=C sed -i "/^\s*freq\s*=\s*/Id" "/etc/audit/auditd.conf"
else
    touch "/etc/audit/auditd.conf"
fi
cp "/etc/audit/auditd.conf" "/etc/audit/auditd.conf.bak"
# Insert at the end of the file
printf '%s\n' "freq = 50" &gt;&gt; "/etc/audit/auditd.conf"
# Clean up after ourselves.
rm "/etc/audit/auditd.conf.bak"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_samba_load_libgfapi" strategy="enable">
var_samba_load_libgfapi="<sub idref="var_samba_load_libgfapi" />"

setsebool -P samba_load_libgfapi $var_samba_load_libgfapi
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_etc_shadow" strategy="configure">
chmod 0000 /etc/shadow
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_enable_homedirs" strategy="enable">
var_httpd_enable_homedirs="<sub idref="var_httpd_enable_homedirs" />"

setsebool -P httpd_enable_homedirs $var_httpd_enable_homedirs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_nagios_run_sudo" strategy="enable">
var_nagios_run_sudo="<sub idref="var_nagios_run_sudo" />"

setsebool -P nagios_run_sudo $var_nagios_run_sudo
</fix><fix rule="configure_tmux_lock_command">
tmux_conf="/etc/tmux.conf"

if grep -qP '^\s*set\s+-g\s+lock-command' "$tmux_conf" ; then
    sed -i 's/^\s*set\s\+-g\s\+lock-command.*$/set -g lock-command vlock/' "$tmux_conf"
else
    echo "set -g lock-command vlock" &gt;&gt; "$tmux_conf"
fi
</fix><fix rule="audit_rules_unsuccessful_file_modification_ftruncate">
<sub idref="function_create_audit_remediation_unsuccessful_file_modification_detailed" />
create_audit_remediation_unsuccessful_file_modification_detailed /etc/audit/rules.d/30-ospp-v42-remediation.rules
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_cron_allow" strategy="configure">

chgrp 0 /etc/cron.allow
</fix><fix rule="accounts_umask_etc_bashrc">
var_accounts_user_umask="<sub idref="var_accounts_user_umask" />"

grep -q umask /etc/bashrc &amp;&amp; \
  sed -i "s/umask.*/umask $var_accounts_user_umask/g" /etc/bashrc
if ! [ $? -eq 0 ]; then
    echo "umask $var_accounts_user_umask" &gt;&gt; /etc/bashrc
fi
</fix><fix rule="audit_rules_immutable">
# Traverse all of:
#
# /etc/audit/audit.rules,			(for auditctl case)
# /etc/audit/rules.d/*.rules			(for augenrules case)
#
# files to check if '-e .*' setting is present in that '*.rules' file already.
# If found, delete such occurrence since auditctl(8) manual page instructs the
# '-e 2' rule should be placed as the last rule in the configuration
find /etc/audit /etc/audit/rules.d -maxdepth 1 -type f -name '*.rules' -exec sed -i '/-e[[:space:]]\+.*/d' {} ';'

# Append '-e 2' requirement at the end of both:
# * /etc/audit/audit.rules file 		(for auditctl case)
# * /etc/audit/rules.d/immutable.rules		(for augenrules case)

for AUDIT_FILE in "/etc/audit/audit.rules" "/etc/audit/rules.d/immutable.rules"
do
	echo '' &gt;&gt; $AUDIT_FILE
	echo '# Set the audit.rules configuration immutable per security requirements' &gt;&gt; $AUDIT_FILE
	echo '# Reboot is required to change audit rules once this setting is applied' &gt;&gt; $AUDIT_FILE
	echo '-e 2' &gt;&gt; $AUDIT_FILE
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_logwatch_can_network_connect_mail" strategy="enable">
var_logwatch_can_network_connect_mail="<sub idref="var_logwatch_can_network_connect_mail" />"

setsebool -P logwatch_can_network_connect_mail $var_logwatch_can_network_connect_mail
</fix><fix rule="accounts_umask_etc_csh_cshrc">
var_accounts_user_umask="<sub idref="var_accounts_user_umask" />"

grep -q umask /etc/csh.cshrc &amp;&amp; \
  sed -i "s/umask.*/umask $var_accounts_user_umask/g" /etc/csh.cshrc
if ! [ $? -eq 0 ]; then
    echo "umask $var_accounts_user_umask" &gt;&gt; /etc/csh.cshrc
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_polipo_connect_all_unreserved" strategy="enable">
var_polipo_connect_all_unreserved="<sub idref="var_polipo_connect_all_unreserved" />"

setsebool -P polipo_connect_all_unreserved $var_polipo_connect_all_unreserved
</fix><fix rule="auditd_data_retention_action_mail_acct">
var_auditd_action_mail_acct="<sub idref="var_auditd_action_mail_acct" />"

AUDITCONFIG=/etc/audit/auditd.conf
<sub idref="function_replace_or_append" />
replace_or_append $AUDITCONFIG '^action_mail_acct' "$var_auditd_action_mail_acct" "@CCENUM@"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_use_samba_home_dirs" strategy="enable">
var_use_samba_home_dirs="<sub idref="var_use_samba_home_dirs" />"

setsebool -P use_samba_home_dirs $var_use_samba_home_dirs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_can_sendmail" strategy="enable">
var_httpd_can_sendmail="<sub idref="var_httpd_can_sendmail" />"

setsebool -P httpd_can_sendmail $var_httpd_can_sendmail
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rlogin_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rlogin.service'
"$SYSTEMCTL_EXEC" disable 'rlogin.service'
"$SYSTEMCTL_EXEC" mask 'rlogin.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rlogin.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rlogin.socket'
    "$SYSTEMCTL_EXEC" disable 'rlogin.socket'
    "$SYSTEMCTL_EXEC" mask 'rlogin.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rlogin.service' || true
</fix><fix rule="audit_rules_dac_modification_fremovexattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fremovexattr.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_python3-subscription-manager-rhsm_installed" strategy="enable">
if ! rpm -q --quiet "python3-subscription-manager-rhsm" ; then
    yum install -y "python3-subscription-manager-rhsm"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_bluetooth_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'bluetooth.service'
"$SYSTEMCTL_EXEC" disable 'bluetooth.service'
"$SYSTEMCTL_EXEC" mask 'bluetooth.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^bluetooth.socket'; then
    "$SYSTEMCTL_EXEC" stop 'bluetooth.socket'
    "$SYSTEMCTL_EXEC" disable 'bluetooth.socket'
    "$SYSTEMCTL_EXEC" mask 'bluetooth.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'bluetooth.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_psacct_installed" strategy="enable">
if ! rpm -q --quiet "psacct" ; then
    yum install -y "psacct"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_webadm_read_user_files" strategy="enable">
var_webadm_read_user_files="<sub idref="var_webadm_read_user_files" />"

setsebool -P webadm_read_user_files $var_webadm_read_user_files
</fix><fix complexity="low" disruption="low" reboot="false" rule="configure_opensc_card_drivers" strategy="configure">
var_smartcard_drivers="<sub idref="var_smartcard_drivers" />"

OPENSC_TOOL="/usr/bin/opensc-tool"

if [ -f "${OPENSC_TOOL}" ]; then
    ${OPENSC_TOOL} -S app:default:card_drivers:$var_smartcard_drivers
fi
</fix><fix rule="audit_rules_unsuccessful_file_modification_renameat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S renameat -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S renameat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S renameat -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S renameat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="network_disable_zeroconf">echo "NOZEROCONF=yes" &gt;&gt; /etc/sysconfig/network
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_sshd_config" strategy="configure">

chgrp 0 /etc/ssh/sshd_config
</fix><fix rule="audit_rules_etc_gshadow_openat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S openat -F a2&amp;03 -F path=/etc/gshadow.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S openat -F a2&amp;03 -F path=/etc/gshadow -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_postgresql_selinux_unconfined_dbadm" strategy="enable">
var_postgresql_selinux_unconfined_dbadm="<sub idref="var_postgresql_selinux_unconfined_dbadm" />"

setsebool -P postgresql_selinux_unconfined_dbadm $var_postgresql_selinux_unconfined_dbadm
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_can_check_spam" strategy="enable">
var_httpd_can_check_spam="<sub idref="var_httpd_can_check_spam" />"

setsebool -P httpd_can_check_spam $var_httpd_can_check_spam
</fix><fix rule="audit_rules_etc_group_open">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S open -F a1&amp;03 -F path=/etc/group.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S open -F a1&amp;03 -F path=/etc/group -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_grub2_cfg" strategy="configure">
chmod 600 /boot/grub2/grub.cfg
</fix><fix rule="selinux_policytype">
var_selinux_policy_name="<sub idref="var_selinux_policy_name" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysconfig/selinux' '^SELINUXTYPE=' $var_selinux_policy_name '@CCENUM@' '%s=%s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_run_ipa" strategy="enable">
var_httpd_run_ipa="<sub idref="var_httpd_run_ipa" />"

setsebool -P httpd_run_ipa $var_httpd_run_ipa
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_postgresql_can_rsync" strategy="enable">
var_postgresql_can_rsync="<sub idref="var_postgresql_can_rsync" />"

setsebool -P postgresql_can_rsync $var_postgresql_can_rsync
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_cron_hourly" strategy="configure">

chgrp 0 /etc/cron.hourly/
</fix><fix rule="audit_rules_execution_restorecon">

PATTERN="-a always,exit -F path=/usr/sbin/restorecon\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/sbin/restorecon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="accounts_passwords_pam_faillock_interval">
var_accounts_passwords_pam_faillock_fail_interval="<sub idref="var_accounts_passwords_pam_faillock_fail_interval" />"

AUTH_FILES=("/etc/pam.d/system-auth" "/etc/pam.d/password-auth")

for pam_file in "${AUTH_FILES[@]}"
do
    # is auth required pam_faillock.so preauth present?
    if grep -qE '^\s*auth\s+required\s+pam_faillock\.so\s+preauth.*$' "$pam_file" ; then
        # is the option set?
        if grep -qE '^\s*auth\s+required\s+pam_faillock\.so\s+preauth.*'"fail_interval"'=([0-9]*).*$' "$pam_file" ; then
            # just change the value of option to a correct value
            sed -i --follow-symlinks 's/\(^auth.*required.*pam_faillock.so.*preauth.*silent.*\)\('"fail_interval"' *= *\).*/\1\2'"$var_accounts_passwords_pam_faillock_fail_interval"'/' "$pam_file"
        # the option is not set.
        else
            # append the option
            sed -i --follow-symlinks '/^auth.*required.*pam_faillock.so.*preauth.*silent.*/ s/$/ '"fail_interval"'='"$var_accounts_passwords_pam_faillock_fail_interval"'/' "$pam_file"
        fi
    # auth required pam_faillock.so preauth is not present, insert the whole line
    else
        sed -i --follow-symlinks '/^auth.*sufficient.*pam_unix.so.*/i auth        required      pam_faillock.so preauth silent '"fail_interval"'='"$var_accounts_passwords_pam_faillock_fail_interval" "$pam_file"
    fi
    # is auth default pam_faillock.so authfail present?
    if grep -qE '^\s*auth\s+(\[default=die\])\s+pam_faillock\.so\s+authfail.*$' "$pam_file" ; then
        # is the option set?
        if grep -qE '^\s*auth\s+(\[default=die\])\s+pam_faillock\.so\s+authfail.*'"fail_interval"'=([0-9]*).*$' "$pam_file" ; then
            # just change the value of option to a correct value
            sed -i --follow-symlinks 's/\(^auth.*[default=die].*pam_faillock.so.*authfail.*\)\('"fail_interval"' *= *\).*/\1\2'"$var_accounts_passwords_pam_faillock_fail_interval"'/' "$pam_file"
        # the option is not set.
        else
            # append the option
            sed -i --follow-symlinks '/^auth.*[default=die].*pam_faillock.so.*authfail.*/ s/$/ '"fail_interval"'='"$var_accounts_passwords_pam_faillock_fail_interval"'/' "$pam_file"
        fi
    # auth default pam_faillock.so authfail is not present, insert the whole line
    else
        sed -i --follow-symlinks '/^auth.*sufficient.*pam_unix.so.*/a auth        [default=die] pam_faillock.so authfail '"fail_interval"'='"$var_accounts_passwords_pam_faillock_fail_interval" "$pam_file"
    fi
    if ! grep -qE '^\s*account\s+required\s+pam_faillock\.so.*$' "$pam_file" ; then
        sed -E -i --follow-symlinks '/^\s*account\s*required\s*pam_unix.so/i account     required      pam_faillock.so' "$pam_file"
    fi
done
</fix><fix rule="auditd_audispd_encrypt_sent_records">


AUDISP_REMOTE_CONFIG="/etc/audit/audisp-remote.conf"
option="^transport"
value="KRB5"
<sub idref="function_replace_or_append" />
replace_or_append $AUDISP_REMOTE_CONFIG "$option" "$value" "@CCENUM@"
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv6_conf_all_accept_source_route" strategy="disable">
sysctl_net_ipv6_conf_all_accept_source_route_value="<sub idref="sysctl_net_ipv6_conf_all_accept_source_route_value" />"

#
# Set runtime for net.ipv6.conf.all.accept_source_route
#
/sbin/sysctl -q -n -w net.ipv6.conf.all.accept_source_route="$sysctl_net_ipv6_conf_all_accept_source_route_value"

#
# If net.ipv6.conf.all.accept_source_route present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv6.conf.all.accept_source_route = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv6.conf.all.accept_source_route' "$sysctl_net_ipv6_conf_all_accept_source_route_value" '@CCENUM@'
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv6_conf_default_accept_ra" strategy="disable">
sysctl_net_ipv6_conf_default_accept_ra_value="<sub idref="sysctl_net_ipv6_conf_default_accept_ra_value" />"

#
# Set runtime for net.ipv6.conf.default.accept_ra
#
/sbin/sysctl -q -n -w net.ipv6.conf.default.accept_ra="$sysctl_net_ipv6_conf_default_accept_ra_value"

#
# If net.ipv6.conf.default.accept_ra present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv6.conf.default.accept_ra = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv6.conf.default.accept_ra' "$sysctl_net_ipv6_conf_default_accept_ra_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xdm_write_home" strategy="enable">
var_xdm_write_home="<sub idref="var_xdm_write_home" />"

setsebool -P xdm_write_home $var_xdm_write_home
</fix><fix rule="sssd_enable_pam_services">

SSSD_SERVICES_PAM_REGEX="^[[:space:]]*\[sssd]([^\n]*\n+)+?[[:space:]]*services.*pam.*$"
SSSD_SERVICES_REGEX="^[[:space:]]*\[sssd]([^\n]*\n+)+?[[:space:]]*services.*$"
SSSD_PAM_SERVICES="[sssd]
services = pam"
SSSD_CONF="/etc/sssd/sssd.conf"

# If there is services line with pam, good
# If there is services line without pam, append pam
# If not echo services line with pam
grep -q "$SSSD_SERVICES_PAM_REGEX" $SSSD_CONF || \
	grep -q "$SSSD_SERVICES_REGEX" $SSSD_CONF &amp;&amp; \
	sed -i "s/$SSSD_SERVICES_REGEX/&amp;, pam/" $SSSD_CONF || \
	echo "$SSSD_PAM_SERVICES" &gt;&gt; $SSSD_CONF
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_execmod" strategy="enable">
var_selinuxuser_execmod="<sub idref="var_selinuxuser_execmod" />"

setsebool -P selinuxuser_execmod $var_selinuxuser_execmod
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_spamassassin_can_network" strategy="enable">
var_spamassassin_can_network="<sub idref="var_spamassassin_can_network" />"

setsebool -P spamassassin_can_network $var_spamassassin_can_network
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_dbus_sssd" strategy="enable">
var_httpd_dbus_sssd="<sub idref="var_httpd_dbus_sssd" />"

setsebool -P httpd_dbus_sssd $var_httpd_dbus_sssd
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_antivirus_use_jit" strategy="enable">
var_antivirus_use_jit="<sub idref="var_antivirus_use_jit" />"

setsebool -P antivirus_use_jit $var_antivirus_use_jit
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_exim_can_connect_db" strategy="enable">
var_exim_can_connect_db="<sub idref="var_exim_can_connect_db" />"

setsebool -P exim_can_connect_db $var_exim_can_connect_db
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_staff_use_svirt" strategy="enable">
var_staff_use_svirt="<sub idref="var_staff_use_svirt" />"

setsebool -P staff_use_svirt $var_staff_use_svirt
</fix><fix rule="harden_sshd_crypto_policy">

cp="CRYPTO_POLICY='-oCiphers=aes128-ctr,aes256-ctr,aes128-cbc,aes256-cbc -oMACs=hmac-sha2-256,hmac-sha2-512 -oGSSAPIKeyExchange=no -oKexAlgorithms=diffie-hellman-group14-sha1,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521 -oHostKeyAlgorithms=ssh-rsa,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384 -oPubkeyAcceptedKeyTypes=ssh-rsa,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384'"
file=/etc/crypto-policies/local.d/opensshserver-ospp.config

#blank line at the begining to ease later readibility
echo '' &gt; "$file"
echo "$cp" &gt;&gt; "$file"
update-crypto-policies
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ftpd_connect_db" strategy="enable">
var_ftpd_connect_db="<sub idref="var_ftpd_connect_db" />"

setsebool -P ftpd_connect_db $var_ftpd_connect_db
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_git_system_use_cifs" strategy="enable">
var_git_system_use_cifs="<sub idref="var_git_system_use_cifs" />"

setsebool -P git_system_use_cifs $var_git_system_use_cifs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_irc_use_any_tcp_ports" strategy="enable">
var_irc_use_any_tcp_ports="<sub idref="var_irc_use_any_tcp_ports" />"

setsebool -P irc_use_any_tcp_ports $var_irc_use_any_tcp_ports
</fix><fix rule="dconf_gnome_screensaver_lock_delay">
var_screensaver_lock_delay="<sub idref="var_screensaver_lock_delay" />"

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/desktop/screensaver\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/desktop/screensaver]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "lock-delay" "uint32 ${var_screensaver_lock_delay}" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "uint32 ${var_screensaver_lock_delay}")"
    if grep -q "^\\s*lock-delay" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*lock-delay\\s*=\\s*.*/lock-delay=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/desktop/screensaver\\]|a\\lock-delay=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/screensaver/lock-delay$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/screensaver/lock-delay" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_wine_mmap_zero_ignore" strategy="enable">
var_wine_mmap_zero_ignore="<sub idref="var_wine_mmap_zero_ignore" />"

setsebool -P wine_mmap_zero_ignore $var_wine_mmap_zero_ignore
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_sctp_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install sctp" /etc/modprobe.d/sctp.conf ; then
	sed -i 's/^install sctp.*/install sctp /bin/true/g' /etc/modprobe.d/sctp.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/sctp.conf
	echo "install sctp /bin/true" &gt;&gt; /etc/modprobe.d/sctp.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_disable_rhosts" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*IgnoreRhosts\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "IgnoreRhosts yes" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "IgnoreRhosts yes" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_xinetd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'xinetd.service'
"$SYSTEMCTL_EXEC" disable 'xinetd.service'
"$SYSTEMCTL_EXEC" mask 'xinetd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^xinetd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'xinetd.socket'
    "$SYSTEMCTL_EXEC" disable 'xinetd.socket'
    "$SYSTEMCTL_EXEC" mask 'xinetd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'xinetd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_nss-tools_installed" strategy="enable">
if ! rpm -q --quiet "nss-tools" ; then
    yum install -y "nss-tools"
fi
</fix><fix rule="mount_option_noexec_remote_filesystems">
<sub idref="function_include_mount_options_functions" />
include_mount_options_functions

ensure_mount_option_for_vfstype "nfs[4]?" "noexec" "" "nfs4"
</fix><fix rule="audit_rules_login_events_tallylog">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/var/log/tallylog" "wa" "logins"
fix_audit_watch_rule "augenrules" "/var/log/tallylog" "wa" "logins"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_systemd-coredump_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'systemd-coredump.service'
"$SYSTEMCTL_EXEC" disable 'systemd-coredump.service'
"$SYSTEMCTL_EXEC" mask 'systemd-coredump.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^systemd-coredump.socket'; then
    "$SYSTEMCTL_EXEC" stop 'systemd-coredump.socket'
    "$SYSTEMCTL_EXEC" disable 'systemd-coredump.socket'
    "$SYSTEMCTL_EXEC" mask 'systemd-coredump.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'systemd-coredump.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_efi_grub2_cfg" strategy="configure">

chgrp 0 /boot/efi/EFI/redhat/grub.cfg
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_etc_group" strategy="configure">
chmod 0644 /etc/group
</fix><fix complexity="low" disruption="low" reboot="false" rule="coredump_disable_storage" strategy="restrict">if [ -e "/etc/systemd/coredump.conf" ] ; then
    LC_ALL=C sed -i "/^\s*Storage\s*=\s*/Id" "/etc/systemd/coredump.conf"
else
    touch "/etc/systemd/coredump.conf"
fi
cp "/etc/systemd/coredump.conf" "/etc/systemd/coredump.conf.bak"
# Insert at the end of the file
printf '%s\n' "Storage=none" &gt;&gt; "/etc/systemd/coredump.conf"
# Clean up after ourselves.
rm "/etc/systemd/coredump.conf.bak"
</fix><fix rule="directory_access_var_log_audit">

PATTERN="-a always,exit -F path=/var/log/audit/\\s\\+.*"
GROUP="access-audit-trail"
FULL_RULE="-a always,exit -F dir=/var/log/audit/ -F perm=r -F auid&gt;=1000 -F auid!=unset -F key=access-audit-trail"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix rule="audit_rules_privileged_commands_sudoedit">

PATTERN="-a always,exit -F path=/usr/bin/sudoedit\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/sudoedit -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_can_connect_ldap" strategy="enable">
var_httpd_can_connect_ldap="<sub idref="var_httpd_can_connect_ldap" />"

setsebool -P httpd_can_connect_ldap $var_httpd_can_connect_ldap
</fix><fix complexity="low" disruption="low" reboot="false" rule="accounts_password_pam_minclass" strategy="restrict">
var_password_pam_minclass="<sub idref="var_password_pam_minclass" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/security/pwquality.conf' '^minclass' $var_password_pam_minclass '@CCENUM@' '%s = %s'
</fix><fix rule="audit_rules_etc_gshadow_open_by_handle_at">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S open_by_handle_at -F a2&amp;03 -F path=/etc/gshadow.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S open_by_handle_at -F a2&amp;03 -F path=/etc/gshadow -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="accounts_passwords_pam_faillock_deny_root">
AUTH_FILES[0]="/etc/pam.d/system-auth"
AUTH_FILES[1]="/etc/pam.d/password-auth"

# This script fixes absence of pam_faillock.so in PAM stack or the
# absense of even_deny_root in pam_faillock.so arguments
# When inserting auth pam_faillock.so entries,
# the entry with preauth argument will be added before pam_unix.so module
# and entry with authfail argument will be added before pam_deny.so module.

# The placement of pam_faillock.so entries will not be changed
# if they are already present

for pamFile in "${AUTH_FILES[@]}"
do
	# if PAM file is missing, system is not using PAM or broken
	if [ ! -f $pamFile ]; then
		continue
	fi

	# is 'auth required' here?
	if grep -q "^auth.*required.*pam_faillock.so.*" $pamFile; then
		# has 'auth required' even_deny_root option?
		if ! grep -q "^auth.*required.*pam_faillock.so.*preauth.*even_deny_root" $pamFile; then
			# even_deny_root is not present
			sed -i --follow-symlinks "s/\(^auth.*required.*pam_faillock.so.*preauth.*\).*/\1 even_deny_root/" $pamFile
		fi
	else
		# no 'auth required', add it
		sed -i --follow-symlinks "/^auth.*pam_unix.so.*/i auth required pam_faillock.so preauth silent even_deny_root" $pamFile
	fi

	# is 'auth [default=die]' here?
	if grep -q "^auth.*\[default=die\].*pam_faillock.so.*" $pamFile; then
		# has 'auth [default=die]' even_deny_root option?
		if ! grep -q "^auth.*\[default=die\].*pam_faillock.so.*authfail.*even_deny_root" $pamFile; then
			# even_deny_root is not present
			sed -i --follow-symlinks "s/\(^auth.*\[default=die\].*pam_faillock.so.*authfail.*\).*/\1 even_deny_root/" $pamFile
		fi
	else
		# no 'auth [default=die]', add it
		sed -i --follow-symlinks "/^auth.*pam_unix.so.*/a auth [default=die] pam_faillock.so authfail silent even_deny_root" $pamFile
	fi
done
</fix><fix rule="audit_rules_login_events_lastlog">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/var/log/lastlog" "wa" "logins"
fix_audit_watch_rule "augenrules" "/var/log/lastlog" "wa" "logins"
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_telnetd_removed" strategy="disable">
# CAUTION: This remediation script will remove telnetd
#	   from the system, and may remove any packages
#	   that depend on telnetd. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "telnetd" ; then
    yum remove -y "telnetd"
fi
</fix><fix rule="display_login_attempts">if grep -q "^session.*pam_lastlog.so" /etc/pam.d/postlogin; then
	sed -i --follow-symlinks "/pam_lastlog.so/d" /etc/pam.d/postlogin
fi

echo "session     [default=1]   pam_lastlog.so nowtmp showfailed" &gt;&gt; /etc/pam.d/postlogin
echo "session     optional      pam_lastlog.so silent noupdate showfailed" &gt;&gt; /etc/pam.d/postlogin
</fix><fix rule="disable_ctrlaltdel_reboot"># The process to disable ctrl+alt+del has changed in RHEL7. 
# Reference: https://access.redhat.com/solutions/1123873

systemctl mask ctrl-alt-del.target
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_samba_domain_controller" strategy="enable">
var_samba_domain_controller="<sub idref="var_samba_domain_controller" />"

setsebool -P samba_domain_controller $var_samba_domain_controller
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_iptables_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'iptables.service'
"$SYSTEMCTL_EXEC" enable 'iptables.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_qpidd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'qpidd.service'
"$SYSTEMCTL_EXEC" disable 'qpidd.service'
"$SYSTEMCTL_EXEC" mask 'qpidd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^qpidd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'qpidd.socket'
    "$SYSTEMCTL_EXEC" disable 'qpidd.socket'
    "$SYSTEMCTL_EXEC" mask 'qpidd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'qpidd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_polipo_use_nfs" strategy="enable">
var_polipo_use_nfs="<sub idref="var_polipo_use_nfs" />"

setsebool -P polipo_use_nfs $var_polipo_use_nfs
</fix><fix rule="auditd_data_retention_space_left">
var_auditd_space_left="<sub idref="var_auditd_space_left" />"

grep -q "^space_left[[:space:]]*=.*$" /etc/audit/auditd.conf &amp;&amp; \
  sed -i "s/^space_left[[:space:]]*=.*$/space_left = $var_auditd_space_left/g" /etc/audit/auditd.conf || \
  echo "space_left = $var_auditd_space_left" &gt;&gt; /etc/audit/auditd.conf
</fix><fix rule="chronyd_client_only">
<sub idref="function_replace_or_append" />
replace_or_append /etc/chrony.conf '^port' 0 '@CCENUM@' '%s %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_saslauthd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'saslauthd.service'
"$SYSTEMCTL_EXEC" disable 'saslauthd.service'
"$SYSTEMCTL_EXEC" mask 'saslauthd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^saslauthd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'saslauthd.socket'
    "$SYSTEMCTL_EXEC" disable 'saslauthd.socket'
    "$SYSTEMCTL_EXEC" mask 'saslauthd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'saslauthd.service' || true
</fix><fix rule="audit_rules_unsuccessful_file_modification_chown">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S chown -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S chown -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S chown -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S chown -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="dconf_gnome_disable_user_admin">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/desktop/lockdown\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/desktop/lockdown]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "user-administration-disabled" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*user-administration-disabled" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*user-administration-disabled\\s*=\\s*.*/user-administration-disabled=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/desktop/lockdown\\]|a\\user-administration-disabled=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/lockdown/user-administration-disabled$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/lockdown/user-administration-disabled" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_sshd_config" strategy="configure">

chown 0 /etc/ssh/sshd_config
</fix><fix rule="usbguard_allow_hid">
if ! grep -Eq '^[ \t]*allow[ \t]+with-interface[ \t]+equals[ \t]+\{[ \t]+03:\*:\*[ \t]+\}[ \t]*$' /etc/usbguard/rules.conf ; then
	echo "allow with-interface equals { 03:*:* }" &gt;&gt; /etc/usbguard/rules.conf
fi
if ! grep -Eq '^[ \t]*allow[ \t]+with-interface[ \t]+equals[ \t]+\{[ \t]+03:\*:\*[ \t]+03:\*:\*[ \t]+\}[ \t]*$' /etc/usbguard/rules.conf ; then
	echo "allow with-interface equals { 03:*:* 03:*:* }" &gt;&gt; /etc/usbguard/rules.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cluster_use_execmem" strategy="enable">
var_cluster_use_execmem="<sub idref="var_cluster_use_execmem" />"

setsebool -P cluster_use_execmem $var_cluster_use_execmem
</fix><fix rule="grub2_vsyscall_argument">

#in later versions of rhel grub2-editenv is used
grub2-editenv - set "$(grub2-editenv - list | grep kernelopts) vsyscall=none"
</fix><fix rule="audit_rules_privileged_commands_newuidmap">

PATTERN="-a always,exit -F path=/usr/bin/newuidmap\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/newuidmap -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_snmpd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'snmpd.service'
"$SYSTEMCTL_EXEC" disable 'snmpd.service'
"$SYSTEMCTL_EXEC" mask 'snmpd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^snmpd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'snmpd.socket'
    "$SYSTEMCTL_EXEC" disable 'snmpd.socket'
    "$SYSTEMCTL_EXEC" mask 'snmpd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'snmpd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_rng-tools_installed" strategy="enable">
if ! rpm -q --quiet "rng-tools" ; then
    yum install -y "rng-tools"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_abrt_removed" strategy="disable">
# CAUTION: This remediation script will remove abrt
#	   from the system, and may remove any packages
#	   that depend on abrt. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "abrt" ; then
    yum remove -y "abrt"
fi
</fix><fix rule="set_password_hashing_algorithm_logindefs">if grep --silent ^ENCRYPT_METHOD /etc/login.defs ; then
	sed -i 's/^ENCRYPT_METHOD.*/ENCRYPT_METHOD SHA512/g' /etc/login.defs
else
	echo "" &gt;&gt; /etc/login.defs
	echo "ENCRYPT_METHOD SHA512" &gt;&gt; /etc/login.defs
fi
</fix><fix rule="audit_rules_unsuccessful_file_modification_unlink">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S unlink -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S unlink -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S unlink -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S unlink -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix rule="kerberos_disable_no_keytab">
rm -f /etc/*.keytab
</fix><fix rule="aide_build_database">
if ! rpm -q --quiet "aide" ; then
    yum install -y "aide"
fi

/usr/sbin/aide --init
/bin/cp -p /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv6_conf_all_accept_ra" strategy="disable">
sysctl_net_ipv6_conf_all_accept_ra_value="<sub idref="sysctl_net_ipv6_conf_all_accept_ra_value" />"

#
# Set runtime for net.ipv6.conf.all.accept_ra
#
/sbin/sysctl -q -n -w net.ipv6.conf.all.accept_ra="$sysctl_net_ipv6_conf_all_accept_ra_value"

#
# If net.ipv6.conf.all.accept_ra present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv6.conf.all.accept_ra = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv6.conf.all.accept_ra' "$sysctl_net_ipv6_conf_all_accept_ra_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cron_system_cronjob_use_shares" strategy="enable">
var_cron_system_cronjob_use_shares="<sub idref="var_cron_system_cronjob_use_shares" />"

setsebool -P cron_system_cronjob_use_shares $var_cron_system_cronjob_use_shares
</fix><fix complexity="low" disruption="low" reboot="false" rule="accounts_password_pam_minlen" strategy="restrict">
var_password_pam_minlen="<sub idref="var_password_pam_minlen" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/security/pwquality.conf' '^minlen' $var_password_pam_minlen '@CCENUM@' '%s = %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_rsync_export_all_ro" strategy="enable">
var_rsync_export_all_ro="<sub idref="var_rsync_export_all_ro" />"

setsebool -P rsync_export_all_ro $var_rsync_export_all_ro
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_entropyd_use_audio" strategy="enable">
var_entropyd_use_audio="<sub idref="var_entropyd_use_audio" />"

setsebool -P entropyd_use_audio $var_entropyd_use_audio
</fix><fix rule="harden_ssh_client_crypto_policy">
#the file starts with 02 so that it is loaded before the 05-redhat.conf which activates configuration provided by system vide crypto policy
file="/etc/ssh/ssh_config.d/02-ospp.conf"
echo -e "Match final all\n\
RekeyLimit 512M 1h\n\
GSSAPIAuthentication no\n\
Ciphers aes256-ctr,aes256-cbc,aes128-ctr,aes128-cbc\n\
PubkeyAcceptedKeyTypes ssh-rsa,ecdsa-sha2-nistp384,ecdsa-sha2-nistp256\n\
MACs hmac-sha2-512,hmac-sha2-256\n\
KexAlgorithms ecdh-sha2-nistp521,ecdh-sha2-nistp384,ecdh-sha2-nistp256,diffie-hellman-group14-sha1\n" &gt; "$file"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_use_ssh_chroot" strategy="enable">
var_selinuxuser_use_ssh_chroot="<sub idref="var_selinuxuser_use_ssh_chroot" />"

setsebool -P selinuxuser_use_ssh_chroot $var_selinuxuser_use_ssh_chroot
</fix><fix rule="audit_rules_time_watch_localtime">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/localtime" "wa" "audit_time_rules"
fix_audit_watch_rule "augenrules" "/etc/localtime" "wa" "audit_time_rules"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_user_exec_content" strategy="enable">
var_user_exec_content="<sub idref="var_user_exec_content" />"

setsebool -P user_exec_content $var_user_exec_content
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_all_send_redirects" strategy="disable">

#
# Set runtime for net.ipv4.conf.all.send_redirects
#
/sbin/sysctl -q -n -w net.ipv4.conf.all.send_redirects="0"

#
# If net.ipv4.conf.all.send_redirects present in /etc/sysctl.conf, change value to "0"
#	else, add "net.ipv4.conf.all.send_redirects = 0" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.all.send_redirects' "0" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_kdump_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'kdump.service'
"$SYSTEMCTL_EXEC" disable 'kdump.service'
"$SYSTEMCTL_EXEC" mask 'kdump.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^kdump.socket'; then
    "$SYSTEMCTL_EXEC" stop 'kdump.socket'
    "$SYSTEMCTL_EXEC" disable 'kdump.socket'
    "$SYSTEMCTL_EXEC" mask 'kdump.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'kdump.service' || true
</fix><fix rule="audit_rules_usergroup_modification_shadow">

# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_watch_rule" />
fix_audit_watch_rule "auditctl" "/etc/shadow" "wa" "audit_rules_usergroup_modification"
fix_audit_watch_rule "augenrules" "/etc/shadow" "wa" "audit_rules_usergroup_modification"
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_crontab" strategy="configure">
chmod 0600 /etc/crontab
</fix><fix rule="rsyslog_remote_loghost">
rsyslog_remote_loghost_address="<sub idref="rsyslog_remote_loghost_address" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/rsyslog.conf' '^\*\.\*' "@@$rsyslog_remote_loghost_address" '@CCENUM@' '%s %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xguest_connect_network" strategy="enable">
var_xguest_connect_network="<sub idref="var_xguest_connect_network" />"

setsebool -P xguest_connect_network $var_xguest_connect_network
</fix><fix rule="banner_etc_motd">
login_banner_text="<sub idref="login_banner_text" />"

# There was a regular-expression matching various banners, needs to be expanded
expanded=$(echo "$login_banner_text" | sed 's/(\\\\\x27)\*/\\\x27/g;s/(\\\x27)\*//g;s/(\^\(.*\)\$|.*$/\1/g;s/\[\\s\\n\][+*]/ /g;s/\\//g;s/[^-]- /\n\n-/g;s/(n)\**//g')
formatted=$(echo "$expanded" | fold -sw 80)

cat &lt;&lt;EOF &gt;/etc/motd
$formatted
EOF

printf "\n" &gt;&gt; /etc/motd
</fix><fix rule="audit_rules_dac_modification_lchown">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S lchown.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_groupowner_cron_monthly" strategy="configure">

chgrp 0 /etc/cron.monthly/
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_libreswan_installed" strategy="enable">
if ! rpm -q --quiet "libreswan" ; then
    yum install -y "libreswan"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_can_network_connect_cobbler" strategy="enable">
var_httpd_can_network_connect_cobbler="<sub idref="var_httpd_can_network_connect_cobbler" />"

setsebool -P httpd_can_network_connect_cobbler $var_httpd_can_network_connect_cobbler
</fix><fix rule="ensure_gpgcheck_local_packages">
<sub idref="function_replace_or_append" />
replace_or_append '/etc/yum.conf' '^localpkg_gpgcheck' '1' '@CCENUM@'
</fix><fix rule="aide_verify_acls">
if ! rpm -q --quiet "aide" ; then
    yum install -y "aide"
fi

aide_conf="/etc/aide.conf"

groups=$(LC_ALL=C grep "^[A-Z]\+" $aide_conf | grep -v "^ALLXTRAHASHES" | cut -f1 -d '=' | tr -d ' ' | sort -u)

for group in $groups
do
	config=$(grep "^$group\s*=" $aide_conf | cut -f2 -d '=' | tr -d ' ')

	if ! [[ $config = *acl* ]]
	then
		if [[ -z $config ]]
		then
			config="acl"
		else
			config=$config"+acl"
		fi
	fi
	sed -i "s/^$group\s*=.*/$group = $config/g" $aide_conf
done
</fix><fix rule="snmpd_not_default_password">
if grep -s "public\|private" /etc/snmp/snmpd.conf | grep -qv "^#"; then
	sed -i "/^\s*#/b;/public\|private/ s/^/#/" /etc/snmp/snmpd.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_kdumpgui_run_bootloader" strategy="enable">
var_kdumpgui_run_bootloader="<sub idref="var_kdumpgui_run_bootloader" />"

setsebool -P kdumpgui_run_bootloader $var_kdumpgui_run_bootloader
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ftpd_connect_all_unreserved" strategy="enable">
var_ftpd_connect_all_unreserved="<sub idref="var_ftpd_connect_all_unreserved" />"

setsebool -P ftpd_connect_all_unreserved $var_ftpd_connect_all_unreserved
</fix><fix rule="accounts_have_homedir_login_defs">
if ! grep -q ^CREATE_HOME /etc/login.defs; then
	echo "CREATE_HOME     yes" &gt;&gt; /etc/login.defs
else
	sed -i "s/^\(CREATE_HOME\).*/\1 yes/g" /etc/login.defs
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cobbler_use_cifs" strategy="enable">
var_cobbler_use_cifs="<sub idref="var_cobbler_use_cifs" />"

setsebool -P cobbler_use_cifs $var_cobbler_use_cifs
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_vim_installed" strategy="enable">
if ! rpm -q --quiet "vim" ; then
    yum install -y "vim"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_racoon_read_shadow" strategy="enable">
var_racoon_read_shadow="<sub idref="var_racoon_read_shadow" />"

setsebool -P racoon_read_shadow $var_racoon_read_shadow
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_run_stickshift" strategy="enable">
var_httpd_run_stickshift="<sub idref="var_httpd_run_stickshift" />"

setsebool -P httpd_run_stickshift $var_httpd_run_stickshift
</fix><fix rule="directory_permissions_var_log_audit">
if LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then
  GROUP=$(awk -F "=" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')
  if ! [ "${GROUP}" == 'root' ] ; then
    chmod 0750 /var/log/audit
  else
    chmod 0700 /var/log/audit
  fi
else
  chmod 0700 /var/log/audit
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_openvpn_enable_homedirs" strategy="enable">
var_openvpn_enable_homedirs="<sub idref="var_openvpn_enable_homedirs" />"

setsebool -P openvpn_enable_homedirs $var_openvpn_enable_homedirs
</fix><fix rule="dconf_gnome_disable_geolocation">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/system/location\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/system/location]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "enabled" "false" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "false")"
    if grep -q "^\\s*enabled" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*enabled\\s*=\\s*.*/enabled=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/system/location\\]|a\\enabled=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/clocks\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/clocks]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "geolocation" "false" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "false")"
    if grep -q "^\\s*geolocation" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*geolocation\\s*=\\s*.*/geolocation=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/clocks\\]|a\\geolocation=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/system/location/enabled$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/system/location/enabled" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/clocks/geolocation$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/clocks/geolocation" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_usb-storage_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install usb-storage" /etc/modprobe.d/usb-storage.conf ; then
	sed -i 's/^install usb-storage.*/install usb-storage /bin/true/g' /etc/modprobe.d/usb-storage.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/usb-storage.conf
	echo "install usb-storage /bin/true" &gt;&gt; /etc/modprobe.d/usb-storage.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_dbadm_exec_content" strategy="enable">
var_dbadm_exec_content="<sub idref="var_dbadm_exec_content" />"

setsebool -P dbadm_exec_content $var_dbadm_exec_content
</fix><fix rule="accounts_passwords_pam_faillock_deny">
var_accounts_passwords_pam_faillock_deny="<sub idref="var_accounts_passwords_pam_faillock_deny" />"

AUTH_FILES=("/etc/pam.d/system-auth" "/etc/pam.d/password-auth")

for pam_file in "${AUTH_FILES[@]}"
do
    # is auth required pam_faillock.so preauth present?
    if grep -qE '^\s*auth\s+required\s+pam_faillock\.so\s+preauth.*$' "$pam_file" ; then
        # is the option set?
        if grep -qE '^\s*auth\s+required\s+pam_faillock\.so\s+preauth.*'"deny"'=([0-9]*).*$' "$pam_file" ; then
            # just change the value of option to a correct value
            sed -i --follow-symlinks 's/\(^auth.*required.*pam_faillock.so.*preauth.*silent.*\)\('"deny"' *= *\).*/\1\2'"$var_accounts_passwords_pam_faillock_deny"'/' "$pam_file"
        # the option is not set.
        else
            # append the option
            sed -i --follow-symlinks '/^auth.*required.*pam_faillock.so.*preauth.*silent.*/ s/$/ '"deny"'='"$var_accounts_passwords_pam_faillock_deny"'/' "$pam_file"
        fi
    # auth required pam_faillock.so preauth is not present, insert the whole line
    else
        sed -i --follow-symlinks '/^auth.*sufficient.*pam_unix.so.*/i auth        required      pam_faillock.so preauth silent '"deny"'='"$var_accounts_passwords_pam_faillock_deny" "$pam_file"
    fi
    # is auth default pam_faillock.so authfail present?
    if grep -qE '^\s*auth\s+(\[default=die\])\s+pam_faillock\.so\s+authfail.*$' "$pam_file" ; then
        # is the option set?
        if grep -qE '^\s*auth\s+(\[default=die\])\s+pam_faillock\.so\s+authfail.*'"deny"'=([0-9]*).*$' "$pam_file" ; then
            # just change the value of option to a correct value
            sed -i --follow-symlinks 's/\(^auth.*[default=die].*pam_faillock.so.*authfail.*\)\('"deny"' *= *\).*/\1\2'"$var_accounts_passwords_pam_faillock_deny"'/' "$pam_file"
        # the option is not set.
        else
            # append the option
            sed -i --follow-symlinks '/^auth.*[default=die].*pam_faillock.so.*authfail.*/ s/$/ '"deny"'='"$var_accounts_passwords_pam_faillock_deny"'/' "$pam_file"
        fi
    # auth default pam_faillock.so authfail is not present, insert the whole line
    else
        sed -i --follow-symlinks '/^auth.*sufficient.*pam_unix.so.*/a auth        [default=die] pam_faillock.so authfail '"deny"'='"$var_accounts_passwords_pam_faillock_deny" "$pam_file"
    fi
    if ! grep -qE '^\s*account\s+required\s+pam_faillock\.so.*$' "$pam_file" ; then
        sed -E -i --follow-symlinks '/^\s*account\s*required\s*pam_unix.so/i account     required      pam_faillock.so' "$pam_file"
    fi
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ksmtuned_use_nfs" strategy="enable">
var_ksmtuned_use_nfs="<sub idref="var_ksmtuned_use_nfs" />"

setsebool -P ksmtuned_use_nfs $var_ksmtuned_use_nfs
</fix><fix rule="dconf_gnome_login_banner_text">
login_banner_text="<sub idref="login_banner_text" />"

expanded=$(echo "$login_banner_text" | sed 's/(\\\\\x27)\*/\\\x27/g;s/(\\\x27)\*//g;s/(\\\\\x27)/tamere/g;s/(\^\(.*\)\$|.*$/\1/g;s/\[\\s\\n\][+*]/ /g;s/\\//g;s/(n)\*/\\n/g;s/\x27/\\\x27/g;')

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/login-screen\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/gdm.d/00-security-settings"
DBDIR="/etc/dconf/db/gdm.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/login-screen]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "banner-message-text" "${expanded}" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "${expanded}")"
    if grep -q "^\\s*banner-message-text" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*banner-message-text\\s*=\\s*.*/banner-message-text=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/login-screen\\]|a\\banner-message-text=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/login-screen/banner-message-text$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/gdm.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/login-screen/banner-message-text" &gt;&gt; "/etc/dconf/db/gdm.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix rule="auditd_data_retention_admin_space_left_action">
var_auditd_admin_space_left_action="<sub idref="var_auditd_admin_space_left_action" />"

AUDITCONFIG=/etc/audit/auditd.conf
<sub idref="function_replace_or_append" />
replace_or_append $AUDITCONFIG '^admin_space_left_action' "$var_auditd_admin_space_left_action" "@CCENUM@"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_squid_connect_any" strategy="enable">
var_squid_connect_any="<sub idref="var_squid_connect_any" />"

setsebool -P squid_connect_any $var_squid_connect_any
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ssh_chroot_rw_homedirs" strategy="enable">
var_ssh_chroot_rw_homedirs="<sub idref="var_ssh_chroot_rw_homedirs" />"

setsebool -P ssh_chroot_rw_homedirs $var_ssh_chroot_rw_homedirs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_use_lpd_server" strategy="enable">
var_use_lpd_server="<sub idref="var_use_lpd_server" />"

setsebool -P use_lpd_server $var_use_lpd_server
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_abrt-plugin-sosreport_removed" strategy="disable">
# CAUTION: This remediation script will remove abrt-plugin-sosreport
#	   from the system, and may remove any packages
#	   that depend on abrt-plugin-sosreport. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "abrt-plugin-sosreport" ; then
    yum remove -y "abrt-plugin-sosreport"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_xorg-x11-server-common_removed" strategy="disable">
# CAUTION: This remediation script will remove xorg-x11-server-common
#	   from the system, and may remove any packages
#	   that depend on xorg-x11-server-common. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "xorg-x11-server-common" ; then
    yum remove -y "xorg-x11-server-common"
fi
</fix><fix rule="audit_rules_privileged_commands_postdrop">

PATTERN="-a always,exit -F path=/usr/sbin/postdrop\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/sbin/postdrop -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_certmonger_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'certmonger.service'
"$SYSTEMCTL_EXEC" disable 'certmonger.service'
"$SYSTEMCTL_EXEC" mask 'certmonger.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^certmonger.socket'; then
    "$SYSTEMCTL_EXEC" stop 'certmonger.socket'
    "$SYSTEMCTL_EXEC" disable 'certmonger.socket'
    "$SYSTEMCTL_EXEC" mask 'certmonger.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'certmonger.service' || true
</fix><fix rule="sshd_disable_compression">
var_sshd_disable_compression="<sub idref="var_sshd_disable_compression" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/ssh/sshd_config' '^Compression' "$var_sshd_disable_compression" '@CCENUM@' '%s %s'
</fix><fix rule="auditd_audispd_syslog_plugin_activated">
var_syslog_active="yes"


AUDISP_SYSLOGCONFIG=/etc/audit/plugins.d/syslog.conf
<sub idref="function_replace_or_append" />
replace_or_append $AUDISP_SYSLOGCONFIG '^active' "$var_syslog_active" "@CCENUM@"
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_git_session_users" strategy="enable">
var_git_session_users="<sub idref="var_git_session_users" />"

setsebool -P git_session_users $var_git_session_users
</fix><fix rule="audit_rules_dac_modification_fsetxattr">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S fsetxattr.*"
	GROUP="perm_mod"
	FULL_RULE="-a always,exit -F arch=$ARCH -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod"

	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_puppetmaster_use_db" strategy="enable">
var_puppetmaster_use_db="<sub idref="var_puppetmaster_use_db" />"

setsebool -P puppetmaster_use_db $var_puppetmaster_use_db
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_virt_sandbox_use_netlink" strategy="enable">
var_virt_sandbox_use_netlink="<sub idref="var_virt_sandbox_use_netlink" />"

setsebool -P virt_sandbox_use_netlink $var_virt_sandbox_use_netlink
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_gssproxy_removed" strategy="disable">
# CAUTION: This remediation script will remove gssproxy
#	   from the system, and may remove any packages
#	   that depend on gssproxy. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "gssproxy" ; then
    yum remove -y "gssproxy"
fi
</fix><fix rule="audit_rules_etc_shadow_openat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S openat -F a2&amp;03 -F path=/etc/shadow.*"
	GROUP="modify"
	FULL_RULE="-a always,exit -F arch=$ARCH -S openat -F a2&amp;03 -F path=/etc/shadow -F auid&gt;=1000 -F auid!=unset -F key=modify"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_nis_enabled" strategy="enable">
var_nis_enabled="<sub idref="var_nis_enabled" />"

setsebool -P nis_enabled $var_nis_enabled
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_print_last_log" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*PrintLastLog\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "PrintLastLog yes" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "PrintLastLog yes" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix rule="audit_rules_file_deletion_events_unlink">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S unlink.*"
	GROUP="delete"
	FULL_RULE="-a always,exit -F arch=$ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_mcstrans_removed" strategy="disable">
# CAUTION: This remediation script will remove mcstrans
#	   from the system, and may remove any packages
#	   that depend on mcstrans. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "mcstrans" ; then
    yum remove -y "mcstrans"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_use_gpg" strategy="enable">
var_httpd_use_gpg="<sub idref="var_httpd_use_gpg" />"

setsebool -P httpd_use_gpg $var_httpd_use_gpg
</fix><fix rule="audit_rules_privileged_commands_chage">

PATTERN="-a always,exit -F path=/usr/bin/chage\\s\\+.*"
GROUP="privileged"
# Although the fix doesn't use ARCH, we reset it because it could have been set by some other remediation
ARCH=""
FULL_RULE="-a always,exit -F path=/usr/bin/chage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged"
# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_ntp_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'ntp.service'
"$SYSTEMCTL_EXEC" enable 'ntp.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_etc_shadow" strategy="configure">

chown 0 /etc/shadow
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_rekey_limit" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*RekeyLimit\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "RekeyLimit 512M 1h" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "RekeyLimit 512M 1h" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_abrt-addon-kerneloops_removed" strategy="disable">
# CAUTION: This remediation script will remove abrt-addon-kerneloops
#	   from the system, and may remove any packages
#	   that depend on abrt-addon-kerneloops. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "abrt-addon-kerneloops" ; then
    yum remove -y "abrt-addon-kerneloops"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_postgresql_selinux_transmit_client_label" strategy="enable">
var_postgresql_selinux_transmit_client_label="<sub idref="var_postgresql_selinux_transmit_client_label" />"

setsebool -P postgresql_selinux_transmit_client_label $var_postgresql_selinux_transmit_client_label
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_debug-shell_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'debug-shell.service'
"$SYSTEMCTL_EXEC" disable 'debug-shell.service'
"$SYSTEMCTL_EXEC" mask 'debug-shell.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^debug-shell.socket'; then
    "$SYSTEMCTL_EXEC" stop 'debug-shell.socket'
    "$SYSTEMCTL_EXEC" disable 'debug-shell.socket'
    "$SYSTEMCTL_EXEC" mask 'debug-shell.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'debug-shell.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cluster_manage_all_files" strategy="enable">
var_cluster_manage_all_files="<sub idref="var_cluster_manage_all_files" />"

setsebool -P cluster_manage_all_files $var_cluster_manage_all_files
</fix><fix rule="audit_rules_file_deletion_events_renameat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S renameat.*"
	GROUP="delete"
	FULL_RULE="-a always,exit -F arch=$ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rhsmcertd_disabled" strategy="disable">

SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rhsmcertd.service'
"$SYSTEMCTL_EXEC" disable 'rhsmcertd.service'
"$SYSTEMCTL_EXEC" mask 'rhsmcertd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rhsmcertd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rhsmcertd.socket'
    "$SYSTEMCTL_EXEC" disable 'rhsmcertd.socket'
    "$SYSTEMCTL_EXEC" mask 'rhsmcertd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rhsmcertd.service' || true
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_authlogin_nsswitch_use_ldap" strategy="enable">
var_authlogin_nsswitch_use_ldap="<sub idref="var_authlogin_nsswitch_use_ldap" />"

setsebool -P authlogin_nsswitch_use_ldap $var_authlogin_nsswitch_use_ldap
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv6_conf_all_forwarding" strategy="disable">
sysctl_net_ipv6_conf_all_forwarding_value="<sub idref="sysctl_net_ipv6_conf_all_forwarding_value" />"

#
# Set runtime for net.ipv6.conf.all.forwarding
#
/sbin/sysctl -q -n -w net.ipv6.conf.all.forwarding="$sysctl_net_ipv6_conf_all_forwarding_value"

#
# If net.ipv6.conf.all.forwarding present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv6.conf.all.forwarding = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv6.conf.all.forwarding' "$sysctl_net_ipv6_conf_all_forwarding_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_secure_mode_insmod" strategy="enable">
var_secure_mode_insmod="<sub idref="var_secure_mode_insmod" />"

setsebool -P secure_mode_insmod $var_secure_mode_insmod
</fix><fix rule="kernel_module_ipv6_option_disabled">
# Prevent the IPv6 kernel module (ipv6) from loading the IPv6 networking stack
echo "options ipv6 disable=1" &gt; /etc/modprobe.d/ipv6.conf

# Since according to: https://access.redhat.com/solutions/72733
# "ipv6 disable=1" options doesn't always disable the IPv6 networking stack from
# loading, instruct also sysctl configuration to disable IPv6 according to:
# https://access.redhat.com/solutions/8709#rhel6disable

declare -a IPV6_SETTINGS=("net.ipv6.conf.all.disable_ipv6" "net.ipv6.conf.default.disable_ipv6")

for setting in "${IPV6_SETTINGS[@]}"
do
	# Set runtime =1 for setting
	/sbin/sysctl -q -n -w "$setting=1"

	# If setting is present in /etc/sysctl.conf, change value to "1"
	# else, add "$setting = 1" to /etc/sysctl.conf
	if grep -q ^"$setting" /etc/sysctl.conf ; then
		sed -i "s/^$setting.*/$setting = 1/g" /etc/sysctl.conf
	else
		echo "" &gt;&gt; /etc/sysctl.conf
		echo "# Set $setting = 1 per security requirements" &gt;&gt; /etc/sysctl.conf
		echo "$setting = 1" &gt;&gt; /etc/sysctl.conf
	fi
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_permissions_cron_hourly" strategy="configure">
chmod 0700 /etc/cron.hourly/
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_disable_empty_passwords" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*PermitEmptyPasswords\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "PermitEmptyPasswords no" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "PermitEmptyPasswords no" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_vsftpd_removed" strategy="disable">
# CAUTION: This remediation script will remove vsftpd
#	   from the system, and may remove any packages
#	   that depend on vsftpd. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "vsftpd" ; then
    yum remove -y "vsftpd"
fi
</fix><fix rule="auditd_data_disk_full_action">
var_auditd_disk_full_action="<sub idref="var_auditd_disk_full_action" />"
<sub idref="function_replace_or_append" />
replace_or_append /etc/audit/auditd.conf '^disk_full_action' "$var_auditd_disk_full_action" "@CCENUM@"
</fix><fix rule="dconf_gnome_disable_wifi_notification">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/nm-applet\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/nm-applet]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "suppress-wireless-networks-available" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*suppress-wireless-networks-available" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*suppress-wireless-networks-available\\s*=\\s*.*/suppress-wireless-networks-available=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/nm-applet\\]|a\\suppress-wireless-networks-available=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/nm-applet/suppress-wireless-networks-available$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/nm-applet/suppress-wireless-networks-available" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix rule="ldap_client_start_tls">

# Use LDAP for authentication
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysconfig/authconfig' '^USELDAPAUTH' 'yes' '@CCENUM@' '%s=%s'

# Configure client to use TLS for all authentications
<sub idref="function_replace_or_append" />
replace_or_append '/etc/nslcd.conf' '^ssl' 'start_tls' '@CCENUM@' '%s %s'
</fix><fix rule="audit_rules_unsuccessful_file_modification_unlinkat">

# First perform the remediation of the syscall rule
# Retrieve hardware architecture of the underlying system
[ "$(getconf LONG_BIT)" = "32" ] &amp;&amp; RULE_ARCHS=("b32") || RULE_ARCHS=("b32" "b64")

for ARCH in "${RULE_ARCHS[@]}"
do
	PATTERN="-a always,exit -F arch=$ARCH -S unlinkat -F exit=-EACCES.*"
	GROUP="access"
	FULL_RULE="-a always,exit -F arch=$ARCH -S unlinkat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access"
	# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
	fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
	fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done

for ARCH in "${RULE_ARCHS[@]}"
do
        PATTERN="-a always,exit -F arch=$ARCH -S unlinkat -F exit=-EPERM.*"
        GROUP="access"
        FULL_RULE="-a always,exit -F arch=$ARCH -S unlinkat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access"
        # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'
<sub idref="function_fix_audit_syscall_rule" />
        fix_audit_syscall_rule "auditctl" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
        fix_audit_syscall_rule "augenrules" "$PATTERN" "$GROUP" "$ARCH" "$FULL_RULE"
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_unified" strategy="enable">
var_httpd_unified="<sub idref="var_httpd_unified" />"

setsebool -P httpd_unified $var_httpd_unified
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_selinuxuser_tcp_server" strategy="enable">
var_selinuxuser_tcp_server="<sub idref="var_selinuxuser_tcp_server" />"

setsebool -P selinuxuser_tcp_server $var_selinuxuser_tcp_server
</fix><fix complexity="low" disruption="low" reboot="false" rule="file_owner_cron_weekly" strategy="configure">

chown 0 /etc/cron.weekly/
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_deny_execmem" strategy="enable">
var_deny_execmem="<sub idref="var_deny_execmem" />"

setsebool -P deny_execmem $var_deny_execmem
</fix><fix complexity="low" disruption="low" reboot="false" rule="sshd_enable_warning_banner" strategy="restrict">if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*Banner\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "Banner /etc/issue" &gt;&gt; "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" &gt; "/etc/ssh/sshd_config"
    printf '%s\n' "Banner /etc/issue" &gt;&gt; "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" &gt;&gt; "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"
</fix><fix rule="no_tmux_in_shells">
if grep -q 'tmux$' /etc/shells ; then
	sed -i '/tmux$/d' /etc/shells
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_tuned_removed" strategy="disable">
# CAUTION: This remediation script will remove tuned
#	   from the system, and may remove any packages
#	   that depend on tuned. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "tuned" ; then
    yum remove -y "tuned"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_polipo_use_cifs" strategy="enable">
var_polipo_use_cifs="<sub idref="var_polipo_use_cifs" />"

setsebool -P polipo_use_cifs $var_polipo_use_cifs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_run_preupgrade" strategy="enable">
var_httpd_run_preupgrade="<sub idref="var_httpd_run_preupgrade" />"

setsebool -P httpd_run_preupgrade $var_httpd_run_preupgrade
</fix><fix rule="auditd_data_retention_num_logs">
var_auditd_num_logs="<sub idref="var_auditd_num_logs" />"

AUDITCONFIG=/etc/audit/auditd.conf
<sub idref="function_replace_or_append" />
replace_or_append $AUDITCONFIG '^num_logs' "$var_auditd_num_logs" "@CCENUM@"
</fix><fix rule="ensure_gpgcheck_globally_activated">
<sub idref="function_replace_or_append" />
replace_or_append "/etc/yum.conf" '^gpgcheck' '1' '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_ntpd_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'ntpd.service'
"$SYSTEMCTL_EXEC" enable 'ntpd.service'
</fix><fix rule="accounts_password_warn_age_login_defs">
var_accounts_password_warn_age_login_defs="<sub idref="var_accounts_password_warn_age_login_defs" />"

grep -q ^PASS_WARN_AGE /etc/login.defs &amp;&amp; \
  sed -i "s/PASS_WARN_AGE.*/PASS_WARN_AGE     $var_accounts_password_warn_age_login_defs/g" /etc/login.defs
if ! [ $? -eq 0 ]; then
    echo "PASS_WARN_AGE      $var_accounts_password_warn_age_login_defs" &gt;&gt; /etc/login.defs
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_inetutils-telnetd_removed" strategy="disable">
# CAUTION: This remediation script will remove inetutils-telnetd
#	   from the system, and may remove any packages
#	   that depend on inetutils-telnetd. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "inetutils-telnetd" ; then
    yum remove -y "inetutils-telnetd"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_gssd_read_tmp" strategy="enable">
var_gssd_read_tmp="<sub idref="var_gssd_read_tmp" />"

setsebool -P gssd_read_tmp $var_gssd_read_tmp
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_conman_can_network" strategy="enable">
var_conman_can_network="<sub idref="var_conman_can_network" />"

setsebool -P conman_can_network $var_conman_can_network
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_auditadm_exec_content" strategy="enable">
var_auditadm_exec_content="<sub idref="var_auditadm_exec_content" />"

setsebool -P auditadm_exec_content $var_auditadm_exec_content
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_graceful_shutdown" strategy="enable">
var_httpd_graceful_shutdown="<sub idref="var_httpd_graceful_shutdown" />"

setsebool -P httpd_graceful_shutdown $var_httpd_graceful_shutdown
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ssh_keysign" strategy="enable">
var_ssh_keysign="<sub idref="var_ssh_keysign" />"

setsebool -P ssh_keysign $var_ssh_keysign
</fix><fix rule="file_permissions_binary_dirs">DIRS="/bin /usr/bin /usr/local/bin /sbin /usr/sbin /usr/local/sbin /usr/libexec"
for dirPath in $DIRS; do
	find "$dirPath" -perm /022 -exec chmod go-w '{}' \;
done
</fix><fix rule="dconf_gnome_disable_automount">

# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/desktop/media-handling\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/desktop/media-handling]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "automount" "false" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "false")"
    if grep -q "^\\s*automount" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*automount\\s*=\\s*.*/automount=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/desktop/media-handling\\]|a\\automount=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/desktop/media-handling\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/desktop/media-handling]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "automount-open" "false" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "false")"
    if grep -q "^\\s*automount-open" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*automount-open\\s*=\\s*.*/automount-open=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/desktop/media-handling\\]|a\\automount-open=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
# If files contain ibus or distro, ignore them.
# The assignment assumes that individual filenames don't contain :
readarray -t SETTINGSFILES &lt; &lt;(grep -r "\\[org/gnome/desktop/media-handling\\]" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
DCONFFILE="/etc/dconf/db/local.d/00-security-settings"
DBDIR="/etc/dconf/db/local.d"

mkdir -p "${DBDIR}"

if [ "${#SETTINGSFILES[@]}" -eq 0 ]
then
    [ ! -z ${DCONFFILE} ] || echo "" &gt;&gt; ${DCONFFILE}
    printf '%s\n' "[org/gnome/desktop/media-handling]" &gt;&gt; ${DCONFFILE}
    printf '%s=%s\n' "autorun-never" "true" &gt;&gt; ${DCONFFILE}
else
    escaped_value="$(sed -e 's/\\/\\\\/g' &lt;&lt;&lt; "true")"
    if grep -q "^\\s*autorun-never" "${SETTINGSFILES[@]}"
    then
        sed -i "s/\\s*autorun-never\\s*=\\s*.*/autorun-never=${escaped_value}/g" "${SETTINGSFILES[@]}"
    else
        sed -i "\\|\\[org/gnome/desktop/media-handling\\]|a\\autorun-never=${escaped_value}" "${SETTINGSFILES[@]}"
    fi
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/media-handling/automount$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/media-handling/automount" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/media-handling/automount-open$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/media-handling/automount-open" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
# Check for setting in any of the DConf db directories
LOCKFILES=$(grep -r "^/org/gnome/desktop/media-handling/autorun-never$" "/etc/dconf/db/" | grep -v 'distro\|ibus' | cut -d":" -f1)
LOCKSFOLDER="/etc/dconf/db/local.d/locks"

mkdir -p "${LOCKSFOLDER}"

if [[ -z "${LOCKFILES}" ]]
then
    echo "/org/gnome/desktop/media-handling/autorun-never" &gt;&gt; "/etc/dconf/db/local.d/locks/00-security-settings-lock"
fi

dconf update
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cron_can_relabel" strategy="enable">
var_cron_can_relabel="<sub idref="var_cron_can_relabel" />"

setsebool -P cron_can_relabel $var_cron_can_relabel
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_kernel_unprivileged_bpf_disabled" strategy="disable">

#
# Set runtime for kernel.unprivileged_bpf_disabled
#
/sbin/sysctl -q -n -w kernel.unprivileged_bpf_disabled="1"

#
# If kernel.unprivileged_bpf_disabled present in /etc/sysctl.conf, change value to "1"
#	else, add "kernel.unprivileged_bpf_disabled = 1" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^kernel.unprivileged_bpf_disabled' "1" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="service_rsyslog_enabled" strategy="enable">
SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" start 'rsyslog.service'
"$SYSTEMCTL_EXEC" enable 'rsyslog.service'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_tftp_anon_write" strategy="enable">
var_tftp_anon_write="<sub idref="var_tftp_anon_write" />"

setsebool -P tftp_anon_write $var_tftp_anon_write
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_xend_run_qemu" strategy="enable">
var_xend_run_qemu="<sub idref="var_xend_run_qemu" />"

setsebool -P xend_run_qemu $var_xend_run_qemu
</fix><fix rule="dconf_db_up_to_date">
dconf update
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv6_conf_default_accept_redirects" strategy="disable">
sysctl_net_ipv6_conf_default_accept_redirects_value="<sub idref="sysctl_net_ipv6_conf_default_accept_redirects_value" />"

#
# Set runtime for net.ipv6.conf.default.accept_redirects
#
/sbin/sysctl -q -n -w net.ipv6.conf.default.accept_redirects="$sysctl_net_ipv6_conf_default_accept_redirects_value"

#
# If net.ipv6.conf.default.accept_redirects present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv6.conf.default.accept_redirects = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv6.conf.default.accept_redirects' "$sysctl_net_ipv6_conf_default_accept_redirects_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_smartmon_3ware" strategy="enable">
var_smartmon_3ware="<sub idref="var_smartmon_3ware" />"

setsebool -P smartmon_3ware $var_smartmon_3ware
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_cobbler_use_nfs" strategy="enable">
var_cobbler_use_nfs="<sub idref="var_cobbler_use_nfs" />"

setsebool -P cobbler_use_nfs $var_cobbler_use_nfs
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_samba_portmapper" strategy="enable">
var_samba_portmapper="<sub idref="var_samba_portmapper" />"

setsebool -P samba_portmapper $var_samba_portmapper
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_all_accept_redirects" strategy="disable">
sysctl_net_ipv4_conf_all_accept_redirects_value="<sub idref="sysctl_net_ipv4_conf_all_accept_redirects_value" />"

#
# Set runtime for net.ipv4.conf.all.accept_redirects
#
/sbin/sysctl -q -n -w net.ipv4.conf.all.accept_redirects="$sysctl_net_ipv4_conf_all_accept_redirects_value"

#
# If net.ipv4.conf.all.accept_redirects present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.conf.all.accept_redirects = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.all.accept_redirects' "$sysctl_net_ipv4_conf_all_accept_redirects_value" '@CCENUM@'
</fix><fix complexity="low" disruption="medium" reboot="true" rule="kernel_module_hfsplus_disabled" strategy="disable">if LC_ALL=C grep -q -m 1 "^install hfsplus" /etc/modprobe.d/hfsplus.conf ; then
	sed -i 's/^install hfsplus.*/install hfsplus /bin/true/g' /etc/modprobe.d/hfsplus.conf
else
	echo -e "\n# Disable per security requirements" &gt;&gt; /etc/modprobe.d/hfsplus.conf
	echo "install hfsplus /bin/true" &gt;&gt; /etc/modprobe.d/hfsplus.conf
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_lsmd_plugin_connect_any" strategy="enable">
var_lsmd_plugin_connect_any="<sub idref="var_lsmd_plugin_connect_any" />"

setsebool -P lsmd_plugin_connect_any $var_lsmd_plugin_connect_any
</fix><fix complexity="low" disruption="medium" reboot="true" rule="sysctl_net_ipv4_conf_default_accept_source_route" strategy="disable">
sysctl_net_ipv4_conf_default_accept_source_route_value="<sub idref="sysctl_net_ipv4_conf_default_accept_source_route_value" />"

#
# Set runtime for net.ipv4.conf.default.accept_source_route
#
/sbin/sysctl -q -n -w net.ipv4.conf.default.accept_source_route="$sysctl_net_ipv4_conf_default_accept_source_route_value"

#
# If net.ipv4.conf.default.accept_source_route present in /etc/sysctl.conf, change value to appropriate value
#	else, add "net.ipv4.conf.default.accept_source_route = value" to /etc/sysctl.conf
#
<sub idref="function_replace_or_append" />
replace_or_append '/etc/sysctl.conf' '^net.ipv4.conf.default.accept_source_route' "$sysctl_net_ipv4_conf_default_accept_source_route_value" '@CCENUM@'
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_ssh_sysadm_login" strategy="enable">
var_ssh_sysadm_login="<sub idref="var_ssh_sysadm_login" />"

setsebool -P ssh_sysadm_login $var_ssh_sysadm_login
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_httpd_setrlimit" strategy="enable">
var_httpd_setrlimit="<sub idref="var_httpd_setrlimit" />"

setsebool -P httpd_setrlimit $var_httpd_setrlimit
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_dbadm_read_user_files" strategy="enable">
var_dbadm_read_user_files="<sub idref="var_dbadm_read_user_files" />"

setsebool -P dbadm_read_user_files $var_dbadm_read_user_files
</fix><fix rule="rsyslog_files_permissions">
# List of log file paths to be inspected for correct permissions
# * Primarily inspect log file paths listed in /etc/rsyslog.conf
RSYSLOG_ETC_CONFIG="/etc/rsyslog.conf"
# * And also the log file paths listed after rsyslog's $IncludeConfig directive
#   (store the result into array for the case there's shell glob used as value of IncludeConfig)
readarray -t RSYSLOG_INCLUDE_CONFIG &lt; &lt;(grep -e "\$IncludeConfig[[:space:]]\+[^[:space:];]\+" /etc/rsyslog.conf | cut -d ' ' -f 2)
# Declare an array to hold the final list of different log file paths
declare -a LOG_FILE_PATHS

# Browse each file selected above as containing paths of log files
# ('/etc/rsyslog.conf' and '/etc/rsyslog.d/*.conf' in the default configuration)
for LOG_FILE in "${RSYSLOG_ETC_CONFIG}" "${RSYSLOG_INCLUDE_CONFIG[@]}"
do
	# From each of these files extract just particular log file path(s), thus:
	# * Ignore lines starting with space (' '), comment ('#"), or variable syntax ('$') characters,
	# * Ignore empty lines,
	# * Strip quotes and closing brackets from paths.
	# * Ignore paths that match /dev|/etc.*\.conf, as those are paths, but likely not log files
	# * From the remaining valid rows select only fields constituting a log file path
	# Text file column is understood to represent a log file path if and only if all of the following are met:
	# * it contains at least one slash '/' character,
	# * it is preceded by space
	# * it doesn't contain space (' '), colon (':'), and semicolon (';') characters
	# Search log file for path(s) only in case it exists!
	if [[ -f "${LOG_FILE}" ]]
	then
		NORMALIZED_CONFIG_FILE_LINES=$(sed -e "/^[[:space:]|#|$]/d" "${LOG_FILE}")
		LINES_WITH_PATHS=$(grep '[^/]*\s\+\S*/\S\+' &lt;&lt;&lt; "${NORMALIZED_CONFIG_FILE_LINES}")
		FILTERED_PATHS=$(sed -e 's/[^\/]*[[:space:]]*\([^:;[:space:]]*\)/\1/g' &lt;&lt;&lt; "${LINES_WITH_PATHS}")
		CLEANED_PATHS=$(sed -e "s/[\"')]//g; /\\/etc.*\.conf/d; /\\/dev\\//d" &lt;&lt;&lt; "${FILTERED_PATHS}")
		MATCHED_ITEMS=$(sed -e "/^$/d" &lt;&lt;&lt; "${CLEANED_PATHS}")
		# Since above sed command might return more than one item (delimited by newline), split the particular
		# matches entries into new array specific for this log file
		readarray -t ARRAY_FOR_LOG_FILE &lt;&lt;&lt; "$MATCHED_ITEMS"
		# Concatenate the two arrays - previous content of $LOG_FILE_PATHS array with
		# items from newly created array for this log file
		LOG_FILE_PATHS+=("${ARRAY_FOR_LOG_FILE[@]}")
		# Delete the temporary array
		unset ARRAY_FOR_LOG_FILE
	fi
done

for LOG_FILE_PATH in "${LOG_FILE_PATHS[@]}"
do
	# Sanity check - if particular $LOG_FILE_PATH is empty string, skip it from further processing
	if [ -z "$LOG_FILE_PATH" ]
	then
		continue
	fi

	

	# Also for each log file check if its permissions differ from 600. If so, correct them
	if [ -f "$LOG_FILE_PATH" ] &amp;&amp; [ "$(/usr/bin/stat -c %a "$LOG_FILE_PATH")" -ne 600 ]
	then
		/bin/chmod 600 "$LOG_FILE_PATH"
	fi
done
</fix><fix complexity="low" disruption="low" reboot="false" rule="sebool_mysql_connect_any" strategy="enable">
var_mysql_connect_any="<sub idref="var_mysql_connect_any" />"

setsebool -P mysql_connect_any $var_mysql_connect_any
</fix><fix rule="sshd_set_keepalive">
var_sshd_set_keepalive="<sub idref="var_sshd_set_keepalive" />"
<sub idref="function_replace_or_append" />
replace_or_append '/etc/ssh/sshd_config' '^ClientAliveCountMax' "$var_sshd_set_keepalive" '@CCENUM@' '%s %s'
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_ypserv_removed" strategy="disable">
# CAUTION: This remediation script will remove ypserv
#	   from the system, and may remove any packages
#	   that depend on ypserv. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

if rpm -q --quiet "ypserv" ; then
    yum remove -y "ypserv"
fi
</fix><fix complexity="low" disruption="low" reboot="false" rule="package_audispd-plugins_installed" strategy="enable">
if ! rpm -q --quiet "audispd-plugins" ; then
    yum install -y "audispd-plugins"
fi
</fix><fix rule="disable_prelink"># prelink not installed
if test -e /etc/sysconfig/prelink -o -e /usr/sbin/prelink; then
    if grep -q ^PRELINKING /etc/sysconfig/prelink
    then
        sed -i 's/^PRELINKING[:blank:]*=[:blank:]*[:alpha:]*/PRELINKING=no/' /etc/sysconfig/prelink
    else
        printf '\n' &gt;&gt; /etc/sysconfig/prelink
        printf '%s\n' '# Set PRELINKING=no per security requirements' 'PRELINKING=no' &gt;&gt; /etc/sysconfig/prelink
    fi

    # Undo previous prelink changes to binaries if prelink is available.
    if test -x /usr/sbin/prelink; then
        /usr/sbin/prelink -ua
    fi
fi
</fix></fix-group></fix-content>